/**
 * @file
 *
 * __WARNING: DO NOT MODIFY THIS FILE.__ This file was generated by `scripts/js_interop.ts` and should not be modified directly.
 * To update the file, modify `data/javascript_definitions.ts` and run `deno task generate-interop` and `deno fmt`.
 *
 * This file contains interop functions for ALL built-in JavaScript functions and properties.
 * It works by converting Ensemble AST Nodes into JavaScript values that are use to execute or return a JavaScript method or property.
 * It also provides runtime type checking, validation, and error handling.
 *
 * In theory the `javascript_definitions.ts` file could be analyzed directly by Ensemble at runtime. However, it is very helpful to pre-generate
 * the interop code so that we can visually and programmatically inspect it to find and fix errors at compile time.
 */
import * as types from '../src/types.ts';
export const javascriptNamespace = new Map<types.MapKeyNode, types.FunctionNode>();

javascriptNamespace.set(
  new types.SymbolNode('decodeURI'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const encodedURI = types.toJs<types.StringNode>(astArgs[0]);
        const result = decodeURI(encodedURI);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "decodeURI"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('decodeURIComponent'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const encodedURIComponent = types.toJs<types.StringNode>(astArgs[0]);
        const result = decodeURIComponent(encodedURIComponent);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "decodeURIComponent"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('encodeURI'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const uri = types.toJs<types.StringNode>(astArgs[0]);
        const result = encodeURI(uri);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "encodeURI"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('encodeURIComponent'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const uriComponent = types.toJs<types.StringNode>(astArgs[0]);
        const result = encodeURIComponent(uriComponent);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "encodeURIComponent"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('eval'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.StringNode>(astArgs[0]);
        const result = eval(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "eval"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('isFinite'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const numberValue = types.toJs<types.NumberNode>(astArgs[0]);
        const result = isFinite(numberValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "isFinite"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('isNaN'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const numberValue = types.toJs<types.StringNode>(astArgs[0]);
        const result = isNaN(numberValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "isNaN"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('parseFloat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const stringValue = types.toJs<types.StringNode>(astArgs[0]);
        const result = parseFloat(stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "parseFloat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('parseInt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isStringNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const stringValue = types.toJs<types.StringNode>(astArgs[0]);
        /* not rest */
        const radix = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        const result = parseInt(stringValue, radix);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "parseInt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = AggregateError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = AggregateError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(AggregateError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = AggregateError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = AggregateError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = AggregateError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new AggregateError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = AggregateError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = AggregateError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = AggregateError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = AggregateError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('AggregateError.prototype.errors'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = AggregateError.prototype.errors;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "AggregateError.prototype.errors"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Array.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Array, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result: unknown[] = [];
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const arrayLength = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Array(arrayLength); // ctor
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* rest */
        const items = astArgs.slice(0).map((x) => types.toJs<types.VectorNode>(x));
        const result = Array(...items); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result: unknown[] = [];
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const arrayLength = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Array(arrayLength); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* rest */
        const items = astArgs.slice(0).map((x) => types.toJs<types.VectorNode>(x));
        const result = new Array(...items); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Array.from(arrayLike);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2]);
        const result = Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.fromAsync'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const iterableOrArrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Array.fromAsync(iterableOrArrayLike);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const iterableOrArrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapFn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.fromAsync(iterableOrArrayLike, mapFn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.fromAsync"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.isArray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const arg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Array.isArray(arg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.isArray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.of'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* rest */
        const items = astArgs.slice(0).map((x) => types.toJs<types.VectorNode>(x));
        const result = Array.of(...items);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.of"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.concat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* rest */
        const items = astArgs.slice(1).map((x) => types.toJs<types.AstNode>(x));
        const result = Array.prototype.concat.call(context, ...items);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.concat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.flat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const depth = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Array.prototype.flat.call(context, depth);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.flat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.flatMap'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isVectorNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callback = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.flatMap.call(context, callback, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.flatMap"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.pop'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.pop.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.pop"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.push'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* rest */
        const items = astArgs.slice(1).map((x) => types.toJs<types.AstNode>(x));
        const result = Array.prototype.push.call(context, ...items);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.push"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1]))) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1]))) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.shift'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.shift.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.shift"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.splice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const deleteCount = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.splice.call(context, start, deleteCount);
        return types.toAst(result);
      }
      if (
        (astArgs.length === 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isVectorNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const deleteCount = types.toJs<types.NumberNode>(astArgs[2]);
        /* rest */
        const items = astArgs.slice(3).map((x) => types.toJs<types.NumberNode>(x));
        const result = Array.prototype.splice.call(context, start, deleteCount, ...items);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.splice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.toSorted.call(context);
        return types.toAst(result);
      }
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFunction = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Array.prototype.toSorted.call(context, compareFunction);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.toSpliced'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isVectorNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const deleteCount = types.toJs<types.NumberNode>(astArgs[2]);
        /* rest */
        const items = astArgs.slice(3).map((x) => types.toJs<types.NumberNode>(x));
        const result = Array.prototype.toSpliced.call(context, start, deleteCount, ...items);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const deleteCount = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Array.prototype.toSpliced.call(context, start, deleteCount);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.toSpliced"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.unshift'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* rest */
        const items = astArgs.slice(1).map((x) => types.toJs<types.AstNode>(x));
        const result = Array.prototype.unshift.call(context, ...items);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.unshift"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = ArrayBuffer.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = ArrayBuffer.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(ArrayBuffer, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = ArrayBuffer[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ArrayBuffer.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const byteLength = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new ArrayBuffer(byteLength); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.isView'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const arg = types.toJs<types.AstNode>(astArgs[0]);
        const result = ArrayBuffer.isView(arg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.isView"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = ArrayBuffer.prototype.slice.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ArrayBuffer.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = ArrayBuffer.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ArrayBuffer.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.add'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.add(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.add"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.and'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.and(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.and"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.compareExchange'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 4) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2]) && types.isNumberNode(astArgs[3])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const expectedValue = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const replacementValue = types.toJs<types.NumberNode>(astArgs[3]);
        const result = Atomics.compareExchange(typedArray, index, expectedValue, replacementValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.compareExchange"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.exchange'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.exchange(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.exchange"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.isLockFree'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const size = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Atomics.isLockFree(size);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.isLockFree"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.load'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        const result = Atomics.load(typedArray, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.load"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.notify'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const count = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Atomics.notify(typedArray, index, count);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.notify"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.or'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.or(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.or"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.store'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.store(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.store"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.sub'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.sub(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.sub"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.wait'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) && types.isNumberNode(astArgs[3])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const timeout = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Atomics.wait(typedArray, index, value, timeout);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.wait"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.waitAsync'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) && types.isNumberNode(astArgs[3])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const timeout = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Atomics.waitAsync(typedArray, index, value, timeout);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.waitAsync"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Atomics.xor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) && types.isNumberNode(astArgs[1]) &&
        types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const typedArray = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Atomics.xor(typedArray, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Atomics.xor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = BigInt.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = BigInt.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(BigInt, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = BigInt[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && (types.isNumberNode(astArgs[0]) || types.isBooleanNode(astArgs[0]) || types.isStringNode(astArgs[0]))) {
        /* not rest */
        const value = types.toJs<types.NumberNode | types.BooleanNode | types.StringNode>(astArgs[0]);
        const result = BigInt(value); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.asIntN'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const bits = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const intValue = types.toJs<types.NumberNode>(astArgs[1]);
        const result = BigInt.asIntN(bits, intValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.asIntN"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt.asUintN'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const bits = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const intValue = types.toJs<types.NumberNode>(astArgs[1]);
        const result = BigInt.asUintN(bits, intValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt.asUintN"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = BigInt64Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = BigInt64Array.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(BigInt64Array, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = BigInt64Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new BigInt64Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new BigInt64Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new BigInt64Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new BigInt64Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new BigInt64Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = BigInt64Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigInt64Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = BigInt64Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = BigInt64Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = BigInt64Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = BigInt64Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = BigInt64Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = BigInt64Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = BigInt64Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = BigInt64Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = BigInt64Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = BigInt64Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigInt64Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = BigInt64Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = BigInt64Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigInt64Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigInt64Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigInt64Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = BigUint64Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = BigUint64Array.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(BigUint64Array, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = BigUint64Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new BigUint64Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new BigUint64Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new BigUint64Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new BigUint64Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new BigUint64Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = BigUint64Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = BigUint64Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = BigUint64Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = BigUint64Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = BigUint64Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = BigUint64Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = BigUint64Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = BigUint64Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = BigUint64Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = BigUint64Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = BigUint64Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = BigUint64Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = BigUint64Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = BigUint64Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = BigUint64Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('BigUint64Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = BigUint64Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "BigUint64Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Boolean.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Boolean.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Boolean, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Boolean[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Boolean.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0] ?? new types.NilNode());
        const result = Boolean(value); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Boolean.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0] ?? new types.NilNode());
        const result = new Boolean(value); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Boolean.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = DataView.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = DataView.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(DataView, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = DataView[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = DataView.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const byteLength = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new DataView(buffer, byteOffset, byteLength); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getBigInt64'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getBigInt64.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getBigInt64"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getBigUint64'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getBigUint64.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getBigUint64"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getFloat32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getFloat32.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getFloat32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getFloat64'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getFloat64.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getFloat64"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getInt16'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getInt16.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getInt16"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getInt32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getInt32.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getInt32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getInt8'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        const result = DataView.prototype.getInt8.call(context, byteOffset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getInt8"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getUint16'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getUint16.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getUint16"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getUint32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isBooleanNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = DataView.prototype.getUint32.call(context, byteOffset, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getUint32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.getUint8'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        const result = DataView.prototype.getUint8.call(context, byteOffset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.getUint8"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setBigInt64'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setBigInt64.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setBigInt64"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setBigUint64'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setBigUint64.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setBigUint64"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setFloat32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setFloat32.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setFloat32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setFloat64'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setFloat64.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setFloat64"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setInt16'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setInt16.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setInt16"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setInt32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setInt32.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setInt32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setInt8'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = DataView.prototype.setInt8.call(context, byteOffset, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setInt8"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setUint16'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setUint16.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setUint16"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setUint32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isBooleanNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const littleEndian = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = DataView.prototype.setUint32.call(context, byteOffset, value, littleEndian);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setUint32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.setUint8'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = DataView.prototype.setUint8.call(context, byteOffset, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.setUint8"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = DataView.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = DataView.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('DataView.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = DataView.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "DataView.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Date.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Date.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Date, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Date[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date(); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Date(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && (types.isStringNode(astArgs[0]) || types.isNumberNode(astArgs[0]))) {
        /* not rest */
        const value = types.toJs<types.StringNode | types.NumberNode>(astArgs[0]);
        const result = new Date(value); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 2 && astArgs.length <= 7) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3]) && types.isNumberNode(astArgs[4]) && types.isNumberNode(astArgs[5]) && types.isNumberNode(astArgs[6])
      ) {
        /* not rest */
        const year = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const monthIndex = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const date = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const hours = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        /* not rest */
        const minutes = types.toJs<types.NumberNode>(astArgs[4] ?? new types.NilNode());
        /* not rest */
        const seconds = types.toJs<types.NumberNode>(astArgs[5] ?? new types.NilNode());
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[6] ?? new types.NilNode());
        const result = new Date(year, monthIndex, date, hours, minutes, seconds, ms); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.now'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Date.now();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.now"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.parse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const dateString = types.toJs<types.StringNode>(astArgs[0]);
        const result = Date.parse(dateString);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.parse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.UTC'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 7) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3]) && types.isNumberNode(astArgs[4]) && types.isNumberNode(astArgs[5]) && types.isNumberNode(astArgs[6])
      ) {
        /* not rest */
        const year = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const month = types.toJs<types.NumberNode>(astArgs[1]);
        /* not rest */
        const date = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const hours = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        /* not rest */
        const minutes = types.toJs<types.NumberNode>(astArgs[4] ?? new types.NilNode());
        /* not rest */
        const seconds = types.toJs<types.NumberNode>(astArgs[5] ?? new types.NilNode());
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[6] ?? new types.NilNode());
        const result = Date.UTC(year, month, date, hours, minutes, seconds, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.UTC"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getDate'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getDate.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getDate"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getDay'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getDay.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getDay"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getFullYear'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getFullYear.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getFullYear"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getHours'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getHours.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getHours"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getMilliseconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getMilliseconds.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getMilliseconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getMinutes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getMinutes.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getMinutes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getMonth'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getMonth.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getMonth"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getSeconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getSeconds.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getSeconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getTime'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getTime.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getTime"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getTimezoneOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getTimezoneOffset.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getTimezoneOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCDate'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCDate.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCDate"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCDay'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCDay.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCDay"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCFullYear'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCFullYear.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCFullYear"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCHours'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCHours.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCHours"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCMilliseconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCMilliseconds.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCMilliseconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCMinutes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCMinutes.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCMinutes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCMonth'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCMonth.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCMonth"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.getUTCSeconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.getUTCSeconds.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.getUTCSeconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setDate'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const date = types.toJs<types.AstNode>(astArgs[1]);
        const result = Date.prototype.setDate.call(context, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setDate"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setFullYear'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const year = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const month = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const date = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Date.prototype.setFullYear.call(context, year, month, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setFullYear"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setHours'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 5) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3]) && types.isNumberNode(astArgs[4])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const hours = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const min = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const sec = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[4] ?? new types.NilNode());
        const result = Date.prototype.setHours.call(context, hours, min, sec, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setHours"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setMilliseconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const ms = types.toJs<types.AstNode>(astArgs[1]);
        const result = Date.prototype.setMilliseconds.call(context, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setMilliseconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setMinutes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const min = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const sec = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Date.prototype.setMinutes.call(context, min, sec, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setMinutes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setMonth'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const month = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const date = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.setMonth.call(context, month, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setMonth"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setSeconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const sec = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.setSeconds.call(context, sec, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setSeconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setTime'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const time = types.toJs<types.AstNode>(astArgs[1]);
        const result = Date.prototype.setTime.call(context, time);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setTime"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCDate'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const date = types.toJs<types.AstNode>(astArgs[1]);
        const result = Date.prototype.setUTCDate.call(context, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCDate"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCFullYear'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const year = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const month = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const date = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Date.prototype.setUTCFullYear.call(context, year, month, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCFullYear"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCHours'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 5) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3]) && types.isNumberNode(astArgs[4])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const hours = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const min = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const sec = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[4] ?? new types.NilNode());
        const result = Date.prototype.setUTCHours.call(context, hours, min, sec, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCHours"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCMilliseconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const ms = types.toJs<types.AstNode>(astArgs[1]);
        const result = Date.prototype.setUTCMilliseconds.call(context, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCMilliseconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCMinutes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const min = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const sec = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Date.prototype.setUTCMinutes.call(context, min, sec, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCMinutes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCMonth'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const month = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const date = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.setUTCMonth.call(context, month, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCMonth"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.setUTCSeconds'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const sec = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const ms = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.setUTCSeconds.call(context, sec, ms);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.setUTCSeconds"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toDateString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.toDateString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toDateString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toISOString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.toISOString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toISOString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toJSON'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Date.prototype.toJSON.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toJSON"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toLocaleDateString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.toLocaleDateString.call(context);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && ((types.isStringNode(astArgs[1])) ||
          (types.isVectorNode(astArgs[1]) && types.isTypedVector(astArgs[1], types.StringNode))) &&
        types.isMapNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const locales = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.toLocaleDateString.call(context, locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toLocaleDateString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && ((types.isStringNode(astArgs[1])) ||
          (types.isVectorNode(astArgs[1]) && types.isTypedVector(astArgs[1], types.StringNode))) &&
        types.isMapNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const locales = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.toLocaleString.call(context, locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toLocaleTimeString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && ((types.isStringNode(astArgs[1])) ||
          (types.isVectorNode(astArgs[1]) && types.isTypedVector(astArgs[1], types.StringNode))) &&
        types.isMapNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const locales = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[2] ?? new types.NilNode());
        const result = Date.prototype.toLocaleTimeString.call(context, locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toLocaleTimeString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toTimeString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.toTimeString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toTimeString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype.toUTCString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Date.prototype.toUTCString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype.toUTCString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Date.prototype[Symbol.toPrimitive]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const hint = types.toJs<types.AstNode>(astArgs[1]);
        const result = Date.prototype[Symbol.toPrimitive].call(context, hint);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Date.prototype[Symbol.toPrimitive]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Error.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Error.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Error, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Error[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Error.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = Error(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new Error(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Error.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Error.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Error.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Error.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Error.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Error.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = EvalError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = EvalError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(EvalError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = EvalError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = EvalError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = EvalError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new EvalError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = EvalError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = EvalError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = EvalError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('EvalError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = EvalError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "EvalError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = FinalizationRegistry.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = FinalizationRegistry.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(FinalizationRegistry, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = FinalizationRegistry[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = FinalizationRegistry.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isFunctionNode(astArgs[0])) {
        /* not rest */
        const cleanupCallback = types.toJs<types.FunctionNode>(astArgs[0]);
        const result = new FinalizationRegistry(cleanupCallback); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.prototype.register'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1]) && types.isAstNode(astArgs[2]) &&
        types.isAtomNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const heldValue = types.toJs<types.AtomNode>(astArgs[2]);
        /* not rest */
        const unregisterToken = types.toJs<types.AstNode>(astArgs[3] ?? new types.NilNode());
        const result = FinalizationRegistry.prototype.register.call(context, target, heldValue, unregisterToken);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.prototype.register"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('FinalizationRegistry.prototype.unregister'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const unregisterToken = types.toJs<types.AstNode>(astArgs[1]);
        const result = FinalizationRegistry.prototype.unregister.call(context, unregisterToken);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "FinalizationRegistry.prototype.unregister"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Float32Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Float32Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Float32Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Float32Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Float32Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Float32Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Float32Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Float32Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Float32Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Float32Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float32Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Float32Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Float32Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Float32Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Float32Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Float32Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Float32Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Float32Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Float32Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Float32Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Float32Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float32Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Float32Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Float32Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float32Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float32Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float32Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Float64Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Float64Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Float64Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Float64Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Float64Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Float64Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Float64Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Float64Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Float64Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Float64Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Float64Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Float64Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Float64Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Float64Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Float64Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Float64Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Float64Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Float64Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Float64Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Float64Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Float64Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Float64Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Float64Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Float64Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Float64Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Float64Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Float64Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Function.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Function, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Function.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode)) {
        /* rest */
        const args = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.StringNode>>(x));
        const result = Function(...args); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Function.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode)) {
        /* rest */
        const args = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.StringNode>>(x));
        const result = new Function(...args); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Function.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Int8Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Int8Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Int8Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Int8Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Int8Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Int8Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Int8Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Int8Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Int8Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Int8Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int8Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int8Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Int8Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Int8Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int8Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int8Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Int8Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int8Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Int8Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Int8Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int8Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int8Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int8Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Int8Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int8Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int8Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int8Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Int16Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Int16Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Int16Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Int16Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Int16Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Int16Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Int16Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Int16Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Int16Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Int16Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int16Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int16Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Int16Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Int16Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int16Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int16Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Int16Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int16Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Int16Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Int16Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int16Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int16Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int16Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Int16Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int16Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int16Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int16Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Int32Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Int32Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Int32Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Int32Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Int32Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Int32Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Int32Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Int32Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Int32Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Int32Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Int32Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int32Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Int32Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Int32Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int32Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int32Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Int32Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Int32Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Int32Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Int32Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int32Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Int32Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Int32Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Int32Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Int32Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Int32Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Int32Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.getCanonicalLocales'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 1) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode)))
      ) {
        /* not rest */
        const locale = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        const result = Intl.getCanonicalLocales(locale);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.getCanonicalLocales"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.supportedValuesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const key = types.toJs<types.StringNode>(astArgs[0]);
        const result = Intl.supportedValuesOf(key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.supportedValuesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.Collator.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.Collator.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.Collator, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.Collator[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Collator(); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Intl.Collator(); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.prototype.compare'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const x = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const y = types.toJs<types.StringNode>(astArgs[2]);
        const result = Intl.Collator.prototype.compare.call(context, x, y);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.prototype.compare"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Collator.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Collator.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 1) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode)))
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        const result = Intl.Collator.supportedLocalesOf(locales);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1]);
        const result = Intl.Collator.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Collator.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DateTimeFormat.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.DateTimeFormat.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.DateTimeFormat, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.DateTimeFormat[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DateTimeFormat.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DateTimeFormat(locales, options); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.DateTimeFormat(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && (types.isNilNode(astArgs[0]) || types.isStringNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const locales = types.toJs<types.NilNode | types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DateTimeFormat.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.prototype.format'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const date = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DateTimeFormat.prototype.format.call(context, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.prototype.format"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.prototype.formatRange'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const startDate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const endDate = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.DateTimeFormat.prototype.formatRange.call(context, startDate, endDate);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.prototype.formatRange"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.prototype.formatRangeToParts'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const startDate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const endDate = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.DateTimeFormat.prototype.formatRangeToParts.call(context, startDate, endDate);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.prototype.formatRangeToParts"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.prototype.formatToParts'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const date = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DateTimeFormat.prototype.formatToParts.call(context, date);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.prototype.formatToParts"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DateTimeFormat.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.DateTimeFormat.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DateTimeFormat.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DisplayNames.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.DisplayNames.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const fnArg1 = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fnArg2 = types.toJs<types.AstNode>(astArgs[2]);
        const result = Function.prototype.call.apply(Intl.DisplayNames, [thisArg, fnArg1, fnArg2]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.DisplayNames[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.DisplayNames.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && (types.isNilNode(astArgs[0]) || types.isStringNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const locales = types.toJs<types.NilNode | types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.DisplayNames(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && (types.isNilNode(astArgs[0]) || types.isStringNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const locales = types.toJs<types.NilNode | types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.DisplayNames.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.prototype.of'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const code = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.DisplayNames.prototype.of.call(context, code);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.prototype.of"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.DisplayNames.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.DisplayNames.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.DisplayNames.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.ListFormat.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.ListFormat.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.ListFormat, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.ListFormat[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.ListFormat.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && (types.isNilNode(astArgs[0]) || types.isStringNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const locales = types.toJs<types.NilNode | types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.ListFormat(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.ListFormat.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.prototype.format'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) && types.isTypedVector(astArgs[1], types.StringNode)) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const list = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.ListFormat.prototype.format.call(context, list);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.prototype.format"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.prototype.formatToParts'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) && types.isTypedVector(astArgs[1], types.StringNode)) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const list = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.ListFormat.prototype.formatToParts.call(context, list);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.prototype.formatToParts"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.ListFormat.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.ListFormat.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.ListFormat.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.Locale.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.Locale.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.Locale, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.Locale[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Locale.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isStringNode(astArgs[0]) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const tag = types.toJs<types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.Locale(tag, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getCalendars'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getCalendars.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getCalendars"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getCollations'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getCollations.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getCollations"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getHourCycles'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getHourCycles.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getHourCycles"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getNumberingSystems'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getNumberingSystems.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getNumberingSystems"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getTextInfo'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getTextInfo.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getTextInfo"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getTimeZones'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getTimeZones.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getTimeZones"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.getWeekInfo'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.getWeekInfo.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.getWeekInfo"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.maximize'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.maximize.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.maximize"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.minimize'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.minimize.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.minimize"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.baseName'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.baseName;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.baseName"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.calendar'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.calendar;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.calendar"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.caseFirst'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.caseFirst;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.caseFirst"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.collation'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.collation;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.collation"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.hourCycle'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.hourCycle;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.hourCycle"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.language'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.language;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.language"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.numberingSystem'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.numberingSystem;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.numberingSystem"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.numeric'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.numeric;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.numeric"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.region'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.region;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.region"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Locale.prototype.script'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Locale.prototype.script;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Locale.prototype.script"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.NumberFormat.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.NumberFormat.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.NumberFormat, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.NumberFormat[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.NumberFormat.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.NumberFormat(locales, options); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.NumberFormat(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.NumberFormat.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.prototype.format'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const numberValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.NumberFormat.prototype.format.call(context, numberValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.prototype.format"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.prototype.formatRange'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const startRange = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const endRange = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.NumberFormat.prototype.formatRange.call(context, startRange, endRange);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.prototype.formatRange"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.prototype.formatRangeToParts'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const startRange = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const endRange = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.NumberFormat.prototype.formatRangeToParts.call(context, startRange, endRange);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.prototype.formatRangeToParts"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.prototype.formatToParts'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const numberValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.NumberFormat.prototype.formatToParts.call(context, numberValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.prototype.formatToParts"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.NumberFormat.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.NumberFormat.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.NumberFormat.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.PluralRules.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.PluralRules.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.PluralRules, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.PluralRules[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.PluralRules.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.PluralRules(locales, options); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.PluralRules(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.PluralRules.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.PluralRules.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.prototype.select'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const numberValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.PluralRules.prototype.select.call(context, numberValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.prototype.select"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.PluralRules.prototype.selectRange'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const startRange = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const endRange = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.PluralRules.prototype.selectRange.call(context, startRange, endRange);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.PluralRules.prototype.selectRange"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.RelativeTimeFormat.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.RelativeTimeFormat.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.RelativeTimeFormat, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.RelativeTimeFormat[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.RelativeTimeFormat.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.RelativeTimeFormat(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && (types.isNilNode(astArgs[0]) || types.isStringNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const locales = types.toJs<types.NilNode | types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.RelativeTimeFormat.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.prototype.format'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const unit = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.RelativeTimeFormat.prototype.format.call(context, value, unit);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.prototype.format"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.prototype.formatToParts'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const unit = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Intl.RelativeTimeFormat.prototype.formatToParts.call(context, value, unit);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.prototype.formatToParts"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.RelativeTimeFormat.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.RelativeTimeFormat.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.RelativeTimeFormat.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.Segmenter.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Intl.Segmenter.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Intl.Segmenter, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Intl.Segmenter[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Intl.Segmenter.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 2) && ((types.isStringNode(astArgs[0])) ||
          (types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.StringNode))) &&
        types.isMapNode(astArgs[1])
      ) {
        /* not rest */
        const locales = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[0] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = new Intl.Segmenter(locales, options); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.supportedLocalesOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && (types.isNilNode(astArgs[0]) || types.isStringNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const locales = types.toJs<types.NilNode | types.StringNode>(astArgs[0]);
        /* not rest */
        const options = types.toJs<types.MapNode>(astArgs[1] ?? new types.NilNode());
        const result = Intl.Segmenter.supportedLocalesOf(locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.supportedLocalesOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.prototype.resolvedOptions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Intl.Segmenter.prototype.resolvedOptions.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.prototype.resolvedOptions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Intl.Segmenter.prototype.segment'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const input = types.toJs<types.AstNode>(astArgs[1]);
        const result = Intl.Segmenter.prototype.segment.call(context, input);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Intl.Segmenter.prototype.segment"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('JSON.parse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isStringNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* not rest */
        const text = types.toJs<types.StringNode>(astArgs[0]);
        /* not rest */
        const reviver = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        const result = JSON.parse(text, reviver);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "JSON.parse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('JSON.stringify'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isFunctionNode(astArgs[1])) &&
        (types.isStringNode(astArgs[2]) || types.isNumberNode(astArgs[2]))
      ) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const replacer = types.toJs<types.NilNode | types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const space = types.toJs<types.StringNode | types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = JSON.stringify(value, replacer, space);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "JSON.stringify"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Map.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Map.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Map, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Map[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Map.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Map(); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 0 && astArgs.length <= 1) &&
        (types.isNilNode(astArgs[0]) ||
          (types.isVectorNode(astArgs[0]) && (astArgs[0].value.length === 2) && types.isAstNode(astArgs[0].value[0]) && types.isAstNode(astArgs[0].value[1])))
      ) {
        /* not rest */
        const entries = types.toJs<types.NilNode | types.VectorNode<types.VectorNode<types.AstNode>>>(astArgs[0] ?? new types.NilNode());
        const result = new Map(entries); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.delete'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        const result = Map.prototype.delete.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.delete"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Map.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callback = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Map.prototype.forEach.call(context, callback, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.get'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        const result = Map.prototype.get.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.get"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.has'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        const result = Map.prototype.has.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.has"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Map.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[2]);
        const result = Map.prototype.set.call(context, key, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Map.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Map.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Map.prototype.size'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Map.prototype.size;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Map.prototype.size"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.abs'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.abs(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.abs"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.acos'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.acos(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.acos"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.acosh'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.acosh(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.acosh"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.asin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.asin(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.asin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.asinh'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.asinh(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.asinh"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.atan'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.atan(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.atan"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.atan2'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const y = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[1]);
        const result = Math.atan2(y, x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.atan2"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.atanh'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.atanh(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.atanh"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.cbrt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.cbrt(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.cbrt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.ceil'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.ceil(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.ceil"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.clz32'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.clz32(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.clz32"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.cos'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.cos(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.cos"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.cosh'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.cosh(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.cosh"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.exp'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.exp(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.exp"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.expm1'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.expm1(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.expm1"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.floor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.floor(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.floor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.fround'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.fround(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.fround"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.hypot'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* rest */
        const values = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.NumberNode>>(x));
        const result = Math.hypot(...values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.hypot"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.imul'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const a = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const b = types.toJs<types.NumberNode>(astArgs[1]);
        const result = Math.imul(a, b);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.imul"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.log'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.log(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.log"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.log10'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.log10(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.log10"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.log1p'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.log1p(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.log1p"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.log2'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.log2(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.log2"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.max'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* rest */
        const values = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.NumberNode>>(x));
        const result = Math.max(...values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.max"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.min'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* rest */
        const values = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.NumberNode>>(x));
        const result = Math.min(...values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.min"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.pow'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isNumberNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const base = types.toJs<types.NumberNode>(astArgs[0]);
        /* not rest */
        const exponent = types.toJs<types.NumberNode>(astArgs[1]);
        const result = Math.pow(base, exponent);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.pow"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.random'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.random();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.random"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.round'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.round(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.round"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.sign'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.sign(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.sign"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.sin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.sin(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.sin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.sinh'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.sinh(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.sinh"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.sqrt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.sqrt(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.sqrt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.tan'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.tan(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.tan"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.tanh'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.tanh(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.tanh"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.trunc'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const x = types.toJs<types.NumberNode>(astArgs[0]);
        const result = Math.trunc(x);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.trunc"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.E'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.E;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.E"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.LN10'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.LN10;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.LN10"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.LN2'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.LN2;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.LN2"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.LOG10E'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.LOG10E;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.LOG10E"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.LOG2E'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.LOG2E;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.LOG2E"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.PI'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.PI;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.PI"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.SQRT1_2'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.SQRT1_2;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.SQRT1_2"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Math.SQRT2'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Math.SQRT2;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Math.SQRT2"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Number.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Number.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Number, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Number[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Number(value); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = new Number(value); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.isFinite'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Number.isFinite(value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.isFinite"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.isInteger'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Number.isInteger(value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.isInteger"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.isNaN'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Number.isNaN(value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.isNaN"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.isSafeInteger'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Number.isSafeInteger(value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.isSafeInteger"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.parseFloat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const stringValue = types.toJs<types.StringNode>(astArgs[0]);
        const result = Number.parseFloat(stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.parseFloat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.parseInt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isStringNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* not rest */
        const stringValue = types.toJs<types.StringNode>(astArgs[0]);
        /* not rest */
        const radix = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        const result = Number.parseInt(stringValue, radix);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.parseInt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.EPSILON'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.EPSILON;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.EPSILON"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.MAX_SAFE_INTEGER'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.MAX_SAFE_INTEGER;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.MAX_SAFE_INTEGER"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.MAX_VALUE'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.MAX_VALUE;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.MAX_VALUE"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.MIN_SAFE_INTEGER'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.MIN_SAFE_INTEGER;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.MIN_SAFE_INTEGER"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.MIN_VALUE'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.MIN_VALUE;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.MIN_VALUE"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.NaN'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.NaN;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.NaN"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.NEGATIVE_INFINITY'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.NEGATIVE_INFINITY;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.NEGATIVE_INFINITY"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.POSITIVE_INFINITY'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Number.POSITIVE_INFINITY;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.POSITIVE_INFINITY"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.prototype.toExponential'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const fractionDigits = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Number.prototype.toExponential.call(context, fractionDigits);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.prototype.toExponential"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.prototype.toFixed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const digits = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Number.prototype.toFixed.call(context, digits);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.prototype.toFixed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Number.prototype.toPrecision'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const precision = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Number.prototype.toPrecision.call(context, precision);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Number.prototype.toPrecision"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object(value); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = new Object(value); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.assign'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const sources = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Object.assign(target, ...sources);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.assign"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.create'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && (types.isNilNode(astArgs[0]) || types.isAstNode(astArgs[0])) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const properties = types.toJs<types.MapNode>(astArgs[1]);
        const result = Object.create(o, properties);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.create"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.defineProperties'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const properties = types.toJs<types.MapNode>(astArgs[1]);
        const result = Object.defineProperties(o, properties);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.defineProperties"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.defineProperty'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1])) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const property = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        /* not rest */
        const descriptor = types.toJs<types.AstNode>(astArgs[2]);
        const result = Object.defineProperty(o, property, descriptor);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.defineProperty"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && (types.isVectorNode(astArgs[0]) || types.isMapNode(astArgs[0]))) {
        /* not rest */
        const o = types.toJs<types.VectorNode | types.MapNode>(astArgs[0]);
        const result = Object.entries(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.freeze'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.freeze(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.freeze"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.fromEntries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 1) && (
          types.isVectorNode(astArgs[0]) &&
          (astArgs[0].value.length === 2) &&
          types.isAstNode(astArgs[0].value[0]) &&
          types.isAstNode(astArgs[0].value[1])
        )
      ) {
        /* not rest */
        const iterable = types.toJs<types.VectorNode<types.VectorNode<types.AstNode>>>(astArgs[0]);
        const result = Object.fromEntries(iterable);
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const iterable = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Object.fromEntries(iterable);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.fromEntries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.getOwnPropertyDescriptor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 2) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1]))
      ) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const p = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        const result = Object.getOwnPropertyDescriptor(o, p);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.getOwnPropertyDescriptor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.getOwnPropertyDescriptors'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const obj = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.getOwnPropertyDescriptors(obj);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.getOwnPropertyDescriptors"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.getOwnPropertyNames'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.getOwnPropertyNames(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.getOwnPropertyNames"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.getOwnPropertySymbols'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.getOwnPropertySymbols(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.getOwnPropertySymbols"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.getPrototypeOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.getPrototypeOf(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.getPrototypeOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.groupBy'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* not rest */
        const items = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const keySelector = types.toJs<types.FunctionNode>(astArgs[1]);
        const result = Object.groupBy(items, keySelector);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.groupBy"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.hasOwn'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 2) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1]))
      ) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const v = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        const result = Object.hasOwn(o, v);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.hasOwn"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.is'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* not rest */
        const value1 = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const value2 = types.toJs<types.AstNode>(astArgs[1]);
        const result = Object.is(value1, value2);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.is"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.isExtensible'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.isExtensible(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.isExtensible"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.isFrozen'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.isFrozen(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.isFrozen"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.isSealed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.isSealed(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.isSealed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.keys(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.preventExtensions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.preventExtensions(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.preventExtensions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.seal'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        const result = Object.seal(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.seal"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.setPrototypeOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isAstNode(astArgs[1]))) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const proto = types.toJs<types.AstNode>(astArgs[1]);
        const result = Object.setPrototypeOf(o, proto);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.setPrototypeOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && (types.isVectorNode(astArgs[0]) || types.isMapNode(astArgs[0]))) {
        /* not rest */
        const o = types.toJs<types.VectorNode | types.MapNode>(astArgs[0]);
        const result = Object.values(o);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Object.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.prototype.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Object.prototype.toString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.prototype.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Object.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Object.prototype.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Object.prototype.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Object.prototype.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Promise.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Promise.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Promise, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Promise[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Promise.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isFunctionNode(astArgs[0])) {
        /* not rest */
        const executor = types.toJs<types.FunctionNode>(astArgs[0]);
        const result = new Promise(executor); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.all'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const values = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Promise.all(values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.all"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.allSettled'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const values = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Promise.allSettled(values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.allSettled"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.any'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const values = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Promise.any(values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.any"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.race'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const values = types.toJs<types.VectorNode>(astArgs[0]);
        const result = Promise.race(values);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.race"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.reject'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const reason = types.toJs<types.AstNode>(astArgs[0]);
        const result = Promise.reject(reason);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.reject"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.resolve'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Promise.resolve(value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.resolve"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.prototype.catch'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isFunctionNode(astArgs[1]))) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const onRejected = types.toJs<types.AstNode>(astArgs[1]);
        const result = Promise.prototype.catch.call(context, onRejected);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.prototype.catch"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.prototype.finally'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isFunctionNode(astArgs[1]))) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const onFinally = types.toJs<types.AstNode>(astArgs[1]);
        const result = Promise.prototype.finally.call(context, onFinally);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.prototype.finally"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Promise.prototype.then'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) &&
        (types.isNilNode(astArgs[2]) || types.isFunctionNode(astArgs[2]))
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const onFulfilled = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const onRejected = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Promise.prototype.then.call(context, onFulfilled, onRejected);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Promise.prototype.then"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Proxy.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const handler = types.toJs<types.MapNode>(astArgs[1]);
        const result = new Proxy(target, handler); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Proxy.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Proxy.revocable'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isMapNode(astArgs[1])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const handler = types.toJs<types.MapNode>(astArgs[1]);
        const result = Proxy.revocable(target, handler);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Proxy.revocable"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = RangeError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = RangeError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(RangeError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = RangeError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RangeError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = RangeError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new RangeError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RangeError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RangeError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RangeError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RangeError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RangeError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RangeError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = ReferenceError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = ReferenceError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(ReferenceError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = ReferenceError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = ReferenceError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = ReferenceError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new ReferenceError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = ReferenceError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = ReferenceError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = ReferenceError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('ReferenceError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = ReferenceError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "ReferenceError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isFunctionNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isVectorNode(astArgs[2])) {
        /* not rest */
        const target = types.toJs<types.FunctionNode>(astArgs[0]);
        /* not rest */
        const thisArgument = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const argumentsList = types.toJs<types.VectorNode>(astArgs[2]);
        const result = Reflect.apply(target, thisArgument, argumentsList);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.construct'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAtomNode(astArgs[0]) && types.isVectorNode(astArgs[1]) && types.isAtomNode(astArgs[2])) {
        /* not rest */
        const target = types.toJs<types.AtomNode>(astArgs[0]);
        /* not rest */
        const argumentsList = types.toJs<types.VectorNode>(astArgs[1]);
        /* not rest */
        const newTarget = types.toJs<types.AtomNode>(astArgs[2] ?? new types.NilNode());
        const result = Reflect.construct(target, argumentsList, newTarget);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.construct"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.defineProperty'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 3) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1])) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const o = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const property = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        /* not rest */
        const descriptor = types.toJs<types.AstNode>(astArgs[2]);
        const result = Reflect.defineProperty(o, property, descriptor);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.defineProperty"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.deleteProperty'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 2) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1]))
      ) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const propertyKey = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        const result = Reflect.deleteProperty(target, propertyKey);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.deleteProperty"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.get'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1])) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const propertyKey = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        /* not rest */
        const receiver = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Reflect.get(target, propertyKey, receiver);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.get"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.getOwnPropertyDescriptor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 2) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1]))
      ) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const propertyKey = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        const result = Reflect.getOwnPropertyDescriptor(target, propertyKey);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.getOwnPropertyDescriptor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.getPrototypeOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        const result = Reflect.getPrototypeOf(target);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.getPrototypeOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.has'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 2) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1]))
      ) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const propertyKey = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        const result = Reflect.has(target, propertyKey);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.has"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.isExtensible'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        const result = Reflect.isExtensible(target);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.isExtensible"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.ownKeys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        const result = Reflect.ownKeys(target);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.ownKeys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.preventExtensions'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        const result = Reflect.preventExtensions(target);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.preventExtensions"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) &&
        (types.isNumberNode(astArgs[1]) || types.isSymbolNode(astArgs[1]) || types.isStringNode(astArgs[1])) && types.isAstNode(astArgs[2]) &&
        types.isAstNode(astArgs[3])
      ) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const propertyKey = types.toJs<types.NumberNode | types.SymbolNode | types.StringNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[2]);
        /* not rest */
        const receiver = types.toJs<types.AstNode>(astArgs[3] ?? new types.NilNode());
        const result = Reflect.set(target, propertyKey, value, receiver);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Reflect.setPrototypeOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isAstNode(astArgs[1]))) {
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const proto = types.toJs<types.AstNode>(astArgs[1]);
        const result = Reflect.setPrototypeOf(target, proto);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Reflect.setPrototypeOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = RegExp.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = RegExp.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(RegExp, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = RegExp[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = RegExp.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isStringNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* not rest */
        const pattern = types.toJs<types.StringNode>(astArgs[0]);
        /* not rest */
        const flags = types.toJs<types.StringNode>(astArgs[1] ?? new types.NilNode());
        const result = RegExp(pattern, flags); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isStringNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* not rest */
        const pattern = types.toJs<types.StringNode>(astArgs[0]);
        /* not rest */
        const flags = types.toJs<types.StringNode>(astArgs[1] ?? new types.NilNode());
        const result = new RegExp(pattern, flags); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.exec'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = RegExp.prototype.exec.call(context, stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.exec"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype[Symbol.match]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = RegExp.prototype[Symbol.match].call(context, stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype[Symbol.match]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype[Symbol.matchAll]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = RegExp.prototype[Symbol.matchAll].call(context, stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype[Symbol.matchAll]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype[Symbol.replace]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const replaceValue = types.toJs<types.StringNode>(astArgs[2]);
        const result = RegExp.prototype[Symbol.replace].call(context, stringValue, replaceValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isFunctionNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const replaceValue = types.toJs<types.StringNode>(astArgs[2]);
        const result = RegExp.prototype[Symbol.replace].call(context, stringValue, replaceValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype[Symbol.replace]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype[Symbol.search]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = RegExp.prototype[Symbol.search].call(context, stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype[Symbol.search]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype[Symbol.split]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const limit = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = RegExp.prototype[Symbol.split].call(context, stringValue, limit);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype[Symbol.split]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.test'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        const result = RegExp.prototype.test.call(context, stringValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.test"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.dotAll'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.dotAll;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.dotAll"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.flags'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.flags;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.flags"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.global'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.global;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.global"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.hasIndices'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.hasIndices;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.hasIndices"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.ignoreCase'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.ignoreCase;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.ignoreCase"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.lastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.lastIndex;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.lastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.multiline'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.multiline;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.multiline"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.source'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.source;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.source"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.sticky'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.sticky;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.sticky"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.unicode'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.unicode;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.unicode"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('RegExp.prototype.unicodeSets'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = RegExp.prototype.unicodeSets;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "RegExp.prototype.unicodeSets"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Set.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Set.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Set, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Set[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Set.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isVectorNode(astArgs[0])) {
        /* not rest */
        const iterable = types.toJs<types.VectorNode>(astArgs[0] ?? new types.NilNode());
        const result = new Set(iterable); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.add'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        const result = Set.prototype.add.call(context, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.add"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.clear'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Set.prototype.clear.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.clear"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.delete'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        const result = Set.prototype.delete.call(context, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.delete"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Set.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Set.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.has'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        const result = Set.prototype.has.call(context, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.has"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Set.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Set.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Set.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Set.prototype.size'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Set.prototype.size;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Set.prototype.size"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = SharedArrayBuffer.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = SharedArrayBuffer.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(SharedArrayBuffer, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = SharedArrayBuffer[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SharedArrayBuffer.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const byteLength = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new SharedArrayBuffer(byteLength); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = SharedArrayBuffer.prototype.slice.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SharedArrayBuffer.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = SharedArrayBuffer.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SharedArrayBuffer.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = String.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = String.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(String, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = String[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = String.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0] ?? new types.NilNode());
        const result = String(value); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0] ?? new types.NilNode());
        const result = new String(value); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.fromCharCode'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* rest */
        const codeUnits = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.NumberNode>>(x));
        const result = String.fromCharCode(...codeUnits);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.fromCharCode"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.fromCodePoint'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* rest */
        const codePoints = astArgs.slice(0).map((x) => types.toJs<types.VectorNode<types.NumberNode>>(x));
        const result = String.fromCodePoint(...codePoints);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.fromCodePoint"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.charAt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.charAt.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.charAt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.charCodeAt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.charCodeAt.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.charCodeAt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.codePointAt'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.codePointAt.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.codePointAt"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.concat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) && types.isTypedVector(astArgs[1], types.StringNode)) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* rest */
        const strings = astArgs.slice(1).map((x) => types.toJs<types.AstNode>(x));
        const result = String.prototype.concat.call(context, ...strings);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.concat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.endsWith'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchString = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const length = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.endsWith.call(context, searchString, length);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.endsWith"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchString = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const position = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.includes.call(context, searchString, position);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchString = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const position = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.indexOf.call(context, searchString, position);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.isWellFormed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.isWellFormed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.isWellFormed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchString = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const position = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.lastIndexOf.call(context, searchString, position);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.localeCompare'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const that = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.localeCompare.call(context, that);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && ((types.isStringNode(astArgs[2])) ||
          (types.isVectorNode(astArgs[2]) && types.isTypedVector(astArgs[2], types.StringNode))) &&
        types.isMapNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const that = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const locales = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.StringNode | types.VectorNode<types.StringNode>>(astArgs[3]);
        const result = String.prototype.localeCompare.call(context, that, locales, options);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) &&
        (types.isNilNode(astArgs[2]) || types.isStringNode(astArgs[2])) && types.isMapNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const that = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const locales = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const options = types.toJs<types.NilNode | types.StringNode>(astArgs[3] ?? new types.NilNode());
        const result = String.prototype.localeCompare.call(context, that, locales, options);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.localeCompare"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.match'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const regexp = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.match.call(context, regexp);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.match"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.matchAll'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const regexp = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.matchAll.call(context, regexp);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.matchAll"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.normalize'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const form = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = String.prototype.normalize.call(context, form);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.normalize"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.padEnd'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const maxLength = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fillString = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.padEnd.call(context, maxLength, fillString);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.padEnd"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.padStart'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const maxLength = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fillString = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.padStart.call(context, maxLength, fillString);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.padStart"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.repeat'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const count = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.repeat.call(context, count);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.repeat"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.replace'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const replaceValue = types.toJs<types.StringNode>(astArgs[2]);
        const result = String.prototype.replace.call(context, stringValue, replaceValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isFunctionNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const replacer = types.toJs<types.StringNode>(astArgs[2]);
        const result = String.prototype.replace.call(context, stringValue, replacer);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.replace"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.replaceAll'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isStringNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const replaceValue = types.toJs<types.StringNode>(astArgs[2]);
        const result = String.prototype.replaceAll.call(context, stringValue, replaceValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isFunctionNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const stringValue = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const replacer = types.toJs<types.StringNode>(astArgs[2]);
        const result = String.prototype.replaceAll.call(context, stringValue, replacer);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.replaceAll"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.search'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const regexp = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.search.call(context, regexp);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.search"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.split'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const limit = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.split.call(context, separator, limit);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.split"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.startsWith'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchString = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const position = types.toJs<types.StringNode>(astArgs[2] ?? new types.NilNode());
        const result = String.prototype.startsWith.call(context, searchString, position);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.startsWith"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.toLocaleLowerCase'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isStringNode(astArgs[1]))) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const locales = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.toLocaleLowerCase.call(context, locales);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.toLocaleLowerCase"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.toLocaleUpperCase'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && (types.isNilNode(astArgs[1]) || types.isStringNode(astArgs[1]))) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const locales = types.toJs<types.AstNode>(astArgs[1]);
        const result = String.prototype.toLocaleUpperCase.call(context, locales);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.toLocaleUpperCase"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.toLowerCase'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.toLowerCase.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.toLowerCase"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.toUpperCase'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.toUpperCase.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.toUpperCase"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.toWellFormed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.toWellFormed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.toWellFormed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.trim'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.trim.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.trim"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.trimEnd'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.trimEnd.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.trimEnd"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype.trimStart'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype.trimStart.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype.trimStart"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = String.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('String.raw'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isMapNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const template = types.toJs<types.MapNode>(astArgs[0]);
        /* rest */
        const substitutions = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = String.raw(template, ...substitutions);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "String.raw"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Symbol.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Symbol.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(Symbol, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Symbol[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && (types.isStringNode(astArgs[0]) || types.isNumberNode(astArgs[0]))) {
        /* not rest */
        const description = types.toJs<types.StringNode | types.NumberNode>(astArgs[0] ?? new types.NilNode());
        const result = Symbol(description); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.asyncIterator'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.asyncIterator;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.asyncIterator"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.for'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const key = types.toJs<types.StringNode>(astArgs[0]);
        const result = Symbol.for(key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.for"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.hasInstance'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.hasInstance;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.hasInstance"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.isConcatSpreadable'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.isConcatSpreadable;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.isConcatSpreadable"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.iterator'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.iterator;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.iterator"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.keyFor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isSymbolNode(astArgs[0])) {
        /* not rest */
        const sym = types.toJs<types.SymbolNode>(astArgs[0]);
        const result = Symbol.keyFor(sym);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.keyFor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.match'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.match;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.match"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.matchAll'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.matchAll;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.matchAll"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.prototype.description'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Symbol.prototype.description;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.prototype.description"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.prototype[Symbol.toPrimitive]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const hint = types.toJs<types.AstNode>(astArgs[1]);
        const result = Symbol.prototype[Symbol.toPrimitive].call(context, hint);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.prototype[Symbol.toPrimitive]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.replace'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.replace;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.replace"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.search'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.search;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.search"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.split'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.split;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.split"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.toPrimitive'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.toPrimitive;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.toPrimitive"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.toStringTag'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.toStringTag;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.toStringTag"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Symbol.unscopables'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Symbol.unscopables;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Symbol.unscopables"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = SyntaxError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = SyntaxError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(SyntaxError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = SyntaxError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = SyntaxError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = SyntaxError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new SyntaxError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = SyntaxError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = SyntaxError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = SyntaxError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('SyntaxError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = SyntaxError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "SyntaxError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = TypeError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = TypeError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(TypeError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = TypeError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = TypeError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = TypeError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new TypeError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = TypeError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = TypeError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = TypeError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('TypeError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = TypeError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "TypeError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = URIError.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = URIError.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(URIError, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = URIError[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = URIError.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = URIError(message); // ctor
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 0 && astArgs.length <= 1) && types.isStringNode(astArgs[0])) {
        /* not rest */
        const message = types.toJs<types.StringNode>(astArgs[0] ?? new types.NilNode());
        const result = new URIError(message); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.prototype.message'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = URIError.prototype.message;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.prototype.message"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.prototype.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = URIError.prototype.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.prototype.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.prototype.cause'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = URIError.prototype.cause;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.prototype.cause"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('URIError.prototype.stack'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = URIError.prototype.stack;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "URIError.prototype.stack"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint8Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Uint8Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint8Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Uint8Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Uint8Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint8Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Uint8Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint8Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Uint8Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint8Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint8Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint8Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint8Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint8Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint8Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Uint8Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint8Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Uint8Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint16Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint16Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Uint16Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint16Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Uint16Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Uint16Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint16Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Uint16Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint16Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Uint16Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint16Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint16Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint16Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint16Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint16Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint16Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint16Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint16Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Uint16Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint16Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint16Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint16Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint16Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Uint16Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint16Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint16Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint16Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint32Array.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint32Array.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Uint32Array, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint32Array[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Uint32Array(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Uint32Array(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint32Array(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Uint32Array(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint32Array(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Uint32Array.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint32Array.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint32Array.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint32Array.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint32Array.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint32Array.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint32Array.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint32Array.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint32Array.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Uint32Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint32Array.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint32Array.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint32Array.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint32Array.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Uint32Array.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint32Array.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint32Array.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint32Array.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8ClampedArray.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint8ClampedArray.bind(thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        const result = Function.prototype.call.apply(Uint8ClampedArray, [thisArg]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = Uint8ClampedArray[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = new Uint8ClampedArray(); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isNumberNode(astArgs[0])) {
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[0]);
        const result = new Uint8ClampedArray(length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const array = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint8ClampedArray(array); // new
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])
      ) {
        /* not rest */
        const buffer = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const byteOffset = types.toJs<types.NumberNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const length = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = new Uint8ClampedArray(buffer, byteOffset, length); // new
        return types.toAst(result);
      }
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const elements = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = new Uint8ClampedArray(elements); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.from'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode)) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        const result = Uint8ClampedArray.from(arrayLike);
        return types.toAst(result);
      }
      if (
        (astArgs.length >= 1 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isTypedVector(astArgs[0], types.NumberNode) &&
        types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])
      ) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const baz = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.from(arrayLike, mapfn, baz);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isVectorNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* not rest */
        const arrayLike = types.toJs<types.VectorNode>(astArgs[0]);
        /* not rest */
        const mapfn = types.toJs<types.FunctionNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.from(arrayLike, mapfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.from"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.BYTES_PER_ELEMENT'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = Uint8ClampedArray.BYTES_PER_ELEMENT;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.BYTES_PER_ELEMENT"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.at'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint8ClampedArray.prototype.at.call(context, index);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.at"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.copyWithin'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 3 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const target = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.NumberNode>(astArgs[2]);
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.copyWithin.call(context, target, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.copyWithin"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.entries'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.entries.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.entries"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.every'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.every.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.every"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.fill'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 4) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2]) &&
        types.isNumberNode(astArgs[3])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[3] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.fill.call(context, value, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.fill"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.filter'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.filter.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.filter"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.find'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.find.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.find"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.findIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.findIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.findIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.findLast'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.findLast.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.findLast"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.findLastIndex'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.findLastIndex.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.findLastIndex"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.forEach'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.forEach.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.forEach"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.includes'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.includes.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.includes"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.indexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isAstNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.AstNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.indexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.indexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.join'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isStringNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const separator = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.join.call(context, separator);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.join"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.keys'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.keys.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.keys"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.lastIndexOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const searchElement = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const fromIndex = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.lastIndexOf.call(context, searchElement, fromIndex);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.lastIndexOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.map'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.map.call(context, callbackfn, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.map"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.reduce'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint8ClampedArray.prototype.reduce.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint8ClampedArray.prototype.reduce.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.reduce"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.reduceRight'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        const result = Uint8ClampedArray.prototype.reduceRight.call(context, callbackfn);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<types.FunctionNode>(astArgs[2]);
        const result = Uint8ClampedArray.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && (types.isFunctionNode(astArgs[1])) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const callbackfn = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const initialValue = types.toJs<>(astArgs[2]);
        const result = Uint8ClampedArray.prototype.reduceRight.call(context, callbackfn, initialValue);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.reduceRight"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.reverse'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.reverse.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.reverse"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1]) &&
        types.isTypedVector(astArgs[1], types.NumberNode) && types.isNumberNode(astArgs[2])
      ) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const array = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const offset = types.toJs<types.VectorNode<types.NumberNode>>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.set.call(context, array, offset);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.slice'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const start = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.slice.call(context, start, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.slice"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.some'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 2 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const predicate = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const thisArg = types.toJs<types.FunctionNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.some.call(context, predicate, thisArg);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.some"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.sort'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.sort.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.sort"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.subarray'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const begin = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        /* not rest */
        const end = types.toJs<types.NumberNode>(astArgs[2] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.subarray.call(context, begin, end);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.subarray"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype[Symbol.iterator]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype[Symbol.iterator].call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype[Symbol.iterator]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.toLocaleString.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.toReversed'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.toReversed.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.toReversed"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.toSorted'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isFunctionNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const compareFn = types.toJs<types.AstNode>(astArgs[1] ?? new types.NilNode());
        const result = Uint8ClampedArray.prototype.toSorted.call(context, compareFn);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.toSorted"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.valueOf.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.values'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.values.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.values"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.with'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isNumberNode(astArgs[1]) && types.isNumberNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const index = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.NumberNode>(astArgs[2]);
        const result = Uint8ClampedArray.prototype.with.call(context, index, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.with"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.buffer'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.buffer;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.buffer"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.byteLength'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.byteLength;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.byteLength"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.byteOffset'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.byteOffset;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.byteOffset"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('Uint8ClampedArray.prototype.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = Uint8ClampedArray.prototype.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "Uint8ClampedArray.prototype.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = WeakMap.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = WeakMap.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(WeakMap, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = WeakMap[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakMap.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length >= 0 && astArgs.length <= 1) && (
          types.isVectorNode(astArgs[0]) &&
          (astArgs[0].value.length === 2) &&
          types.isAstNode(astArgs[0].value[0]) &&
          types.isAstNode(astArgs[0].value[1])
        )
      ) {
        /* not rest */
        const entries = types.toJs<types.VectorNode<types.VectorNode<types.AstNode>>>(astArgs[0] ?? new types.NilNode());
        const result = new WeakMap(entries); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.prototype.delete'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        const result = WeakMap.prototype.delete.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.prototype.delete"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.prototype.get'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        const result = WeakMap.prototype.get.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.prototype.get"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.prototype.has'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        const result = WeakMap.prototype.has.call(context, key);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.prototype.has"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakMap.prototype.set'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 3) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1]) && types.isAstNode(astArgs[2])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const key = types.toJs<types.AstNode>(astArgs[1]);
        /* not rest */
        const value = types.toJs<types.AtomNode>(astArgs[2]);
        const result = WeakMap.prototype.set.call(context, key, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakMap.prototype.set"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = WeakRef.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = WeakRef.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(WeakRef, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = WeakRef[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakRef.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAtomNode(astArgs[0])) {
        /* not rest */
        const target = types.toJs<types.AtomNode>(astArgs[0]);
        const result = new WeakRef(target); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakRef.prototype.deref'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        const result = WeakRef.prototype.deref.call(context);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakRef.prototype.deref"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.apply'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length >= 1 && astArgs.length <= 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* not rest */
        const argArray = types.toJs<types.VectorNode>(astArgs[1] ?? new types.NilNode());
        const result = WeakSet.apply(thisArg, argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.apply"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.bind'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = WeakSet.bind(thisArg, ...argArray);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.bind"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.call'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isVectorNode(astArgs[1])) {
        /* not rest */
        const thisArg = types.toJs<types.AstNode>(astArgs[0]);
        /* rest */
        const argArray = astArgs.slice(1).map((x) => types.toJs<types.VectorNode>(x));
        const result = Function.prototype.call.apply(WeakSet, [thisArg, ...argArray]);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.call"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet[Symbol.hasInstance]'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 1) && types.isAstNode(astArgs[0])) {
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[0]);
        const result = WeakSet[Symbol.hasInstance](value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet[Symbol.hasInstance]"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.toString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.toString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.toString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.length'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.length;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.length"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.name'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.name;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.name"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.prototype'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.prototype;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.prototype"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.toLocaleString'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.toLocaleString();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.toLocaleString"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.valueOf'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.valueOf();
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.valueOf"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.constructor'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 0)) {
        const result = WeakSet.constructor;
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.constructor"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.new'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if (
        (astArgs.length === 1) &&
        (types.isNilNode(astArgs[0]) ||
          (types.isVectorNode(astArgs[0]) && (astArgs[0].value.length === 2) && types.isAstNode(astArgs[0].value[0]) && types.isAstNode(astArgs[0].value[1])))
      ) {
        /* not rest */
        const values = types.toJs<types.NilNode | types.VectorNode<types.VectorNode<types.AstNode>>>(astArgs[0]);
        const result = new WeakSet(values); // new
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.new"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.prototype.add'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        const result = WeakSet.prototype.add.call(context, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.prototype.add"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.prototype.delete'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        const result = WeakSet.prototype.delete.call(context, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.prototype.delete"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);

javascriptNamespace.set(
  new types.SymbolNode('WeakSet.prototype.has'),
  new types.FunctionNode((...astArgs: types.AstNode[]): types.AstNode => {
    try {
      if ((astArgs.length === 2) && types.isAstNode(astArgs[0]) && types.isAtomNode(astArgs[1])) {
        /* context */
        const context = types.toJs<undefined>(astArgs[0]);
        /* not rest */
        const value = types.toJs<types.AstNode>(astArgs[1]);
        const result = WeakSet.prototype.has.call(context, value);
        return types.toAst(result);
      }
      return types.createErrorNode(types.createStringNode('Invalid arguments to "WeakSet.prototype.has"'));
    } catch (e) {
      if (types.isErrorNode(e)) return e;
      if (types.isAstNode(e)) return types.createErrorNode(e);
      if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
      return types.createErrorNode(types.createStringNode(String(e)));
    }
  }),
);
