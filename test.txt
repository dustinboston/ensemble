Testing evaluation of arithmetic operations
TEST: '(+ 1 2)' -> ['',3] -> SUCCESS
TEST: '(+ 5 (* 2 3))' -> ['',11] -> SUCCESS
TEST: '(- (+ 5 (* 2 3)) 3)' -> ['',8] -> SUCCESS
TEST: '(/ (- (+ 5 (* 2 3)) 3) 4)' -> ['',2] -> SUCCESS
TEST: '(/ (- (+ 515 (* 87 311)) 302) 27)' -> ['',1010] -> SUCCESS
TEST: '(* -3 6)' -> ['',-18] -> SUCCESS
TEST: '(/ (- (+ 515 (* -87 311)) 296) 27)' -> ['',-994] -> SUCCESS
TEST: '(abc 1 2 3)' -> ['.+',] -> SUCCESS
Testing empty list
TEST: '()' -> ['',()] -> SUCCESS

-------- Deferrable Functionality --------
Testing evaluation within collection literals
TEST: '[1 2 (+ 1 2)]' -> ['',[1 2 3]] -> SUCCESS
TEST: '{"a" (+ 7 8)}' -> ['',{"a" 15}] -> SUCCESS
TEST: '{a: (+ 7 8)}' -> ['',{a: 15}] -> SUCCESS
Check that evaluation hasn't broken empty collections
TEST: '[]' -> ['',[]] -> SUCCESS
TEST: '{}' -> ['',{}] -> SUCCESS

TEST RESULTS (for ./tests/mal/step2_eval.mal):
    0: soft failing tests
    0: failing tests
   14: passing tests
   14: total tests

----------------------------------------------
Testing REPL_ENV
TEST: '(+ 1 2)' -> ['',3] -> SUCCESS
TEST: '(/ (- (+ 5 (* 2 3)) 3) 4)' -> ['',2] -> SUCCESS
Testing def!
TEST: '(def! x 3)' -> ['',3] -> SUCCESS
TEST: 'x' -> ['',3] -> SUCCESS
TEST: '(def! x 4)' -> ['',4] -> SUCCESS
TEST: 'x' -> ['',4] -> SUCCESS
TEST: '(def! y (+ 1 7))' -> ['',8] -> SUCCESS
TEST: 'y' -> ['',8] -> SUCCESS
Verifying symbols are case-sensitive
TEST: '(def! mynum 111)' -> ['',111] -> SUCCESS
TEST: '(def! MYNUM 222)' -> ['',222] -> SUCCESS
TEST: 'mynum' -> ['',111] -> SUCCESS
TEST: 'MYNUM' -> ['',222] -> SUCCESS
Check env lookup non-fatal error
TEST: '(abc 1 2 3)' -> [".*\\'?abc\\'? not found.*",] -> SUCCESS
Check that error aborts def!
TEST: '(def! w 123)' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! w (abc))' -> ['',] -> SUCCESS (result ignored)
TEST: 'w' -> ['',123] -> SUCCESS
Testing let*
TEST: '(let* (z 9) z)' -> ['',9] -> SUCCESS
TEST: '(let* (x 9) x)' -> ['',9] -> SUCCESS
TEST: 'x' -> ['',4] -> SUCCESS
TEST: '(let* (z (+ 2 3)) (+ 1 z))' -> ['',6] -> SUCCESS
TEST: '(let* (p (+ 2 3) q (+ 2 p)) (+ p q))' -> ['',12] -> SUCCESS
TEST: '(def! y (let* (z 7) z))' -> ['',] -> SUCCESS (result ignored)
TEST: 'y' -> ['',7] -> SUCCESS
Testing outer environment
TEST: '(def! a 4)' -> ['',4] -> SUCCESS
TEST: '(let* (q 9) q)' -> ['',9] -> SUCCESS
TEST: '(let* (q 9) a)' -> ['',4] -> SUCCESS
TEST: '(let* (z 2) (let* (q 9) a))' -> ['',4] -> SUCCESS

-------- Deferrable Functionality --------
Testing let* with vector bindings
TEST: '(let* [z 9] z)' -> ['',9] -> SUCCESS
TEST: '(let* [p (+ 2 3) q (+ 2 p)] (+ p q))' -> ['',12] -> SUCCESS
Testing vector evaluation
TEST: '(let* (a 5 b 6) [3 4 a [b 7] 8])' -> ['',[3 4 5 [6 7] 8]] -> SUCCESS

-------- Optional Functionality --------
Check that last assignment takes priority
TEST: '(let* (x 2 x 3) x)' -> ['',3] -> SUCCESS

TEST RESULTS (for ./tests/mal/step3_env.mal):
    0: soft failing tests
    0: failing tests
   31: passing tests
   31: total tests

----------------------------------------------
-----------------------------------------------------
Testing list functions
TEST: '(list)' -> ['',()] -> SUCCESS
TEST: '(list? (list))' -> ['',true] -> SUCCESS
TEST: '(empty? (list))' -> ['',true] -> SUCCESS
TEST: '(empty? (list 1))' -> ['',false] -> SUCCESS
TEST: '(list 1 2 3)' -> ['',(1 2 3)] -> SUCCESS
TEST: '(count (list 1 2 3))' -> ['',3] -> SUCCESS
TEST: '(count (list))' -> ['',0] -> SUCCESS
TEST: '(count nil)' -> ['',0] -> SUCCESS
TEST: '(if (> (count (list 1 2 3)) 3) 89 78)' -> ['',78] -> SUCCESS
TEST: '(if (>= (count (list 1 2 3)) 3) 89 78)' -> ['',89] -> SUCCESS
Testing if form
TEST: '(if true 7 8)' -> ['',7] -> SUCCESS
TEST: '(if false 7 8)' -> ['',8] -> SUCCESS
TEST: '(if false 7 false)' -> ['',false] -> SUCCESS
TEST: '(if true (+ 1 7) (+ 1 8))' -> ['',8] -> SUCCESS
TEST: '(if false (+ 1 7) (+ 1 8))' -> ['',9] -> SUCCESS
TEST: '(if nil 7 8)' -> ['',8] -> SUCCESS
TEST: '(if 0 7 8)' -> ['',7] -> SUCCESS
TEST: '(if (list) 7 8)' -> ['',7] -> SUCCESS
TEST: '(if (list 1 2 3) 7 8)' -> ['',7] -> SUCCESS
TEST: '(= (list) nil)' -> ['',false] -> SUCCESS
Testing 1-way if form
TEST: '(if false (+ 1 7))' -> ['',nil] -> SUCCESS
TEST: '(if nil 8)' -> ['',nil] -> SUCCESS
TEST: '(if nil 8 7)' -> ['',7] -> SUCCESS
TEST: '(if true (+ 1 7))' -> ['',8] -> SUCCESS
Testing basic conditionals
TEST: '(= 2 1)' -> ['',false] -> SUCCESS
TEST: '(= 1 1)' -> ['',true] -> SUCCESS
TEST: '(= 1 2)' -> ['',false] -> SUCCESS
TEST: '(= 1 (+ 1 1))' -> ['',false] -> SUCCESS
TEST: '(= 2 (+ 1 1))' -> ['',true] -> SUCCESS
TEST: '(= nil 1)' -> ['',false] -> SUCCESS
TEST: '(= nil nil)' -> ['',true] -> SUCCESS
TEST: '(> 2 1)' -> ['',true] -> SUCCESS
TEST: '(> 1 1)' -> ['',false] -> SUCCESS
TEST: '(> 1 2)' -> ['',false] -> SUCCESS
TEST: '(>= 2 1)' -> ['',true] -> SUCCESS
TEST: '(>= 1 1)' -> ['',true] -> SUCCESS
TEST: '(>= 1 2)' -> ['',false] -> SUCCESS
TEST: '(< 2 1)' -> ['',false] -> SUCCESS
TEST: '(< 1 1)' -> ['',false] -> SUCCESS
TEST: '(< 1 2)' -> ['',true] -> SUCCESS
TEST: '(<= 2 1)' -> ['',false] -> SUCCESS
TEST: '(<= 1 1)' -> ['',true] -> SUCCESS
TEST: '(<= 1 2)' -> ['',true] -> SUCCESS
Testing equality
TEST: '(= 1 1)' -> ['',true] -> SUCCESS
TEST: '(= 0 0)' -> ['',true] -> SUCCESS
TEST: '(= 1 0)' -> ['',false] -> SUCCESS
TEST: '(= true true)' -> ['',true] -> SUCCESS
TEST: '(= false false)' -> ['',true] -> SUCCESS
TEST: '(= nil nil)' -> ['',true] -> SUCCESS
TEST: '(= (list) (list))' -> ['',true] -> SUCCESS
TEST: '(= (list) ())' -> ['',true] -> SUCCESS
TEST: '(= (list 1 2) (list 1 2))' -> ['',true] -> SUCCESS
TEST: '(= (list 1) (list))' -> ['',false] -> SUCCESS
TEST: '(= (list) (list 1))' -> ['',false] -> SUCCESS
TEST: '(= 0 (list))' -> ['',false] -> SUCCESS
TEST: '(= (list) 0)' -> ['',false] -> SUCCESS
TEST: '(= (list nil) (list))' -> ['',false] -> SUCCESS
Testing builtin and user defined functions
TEST: '(+ 1 2)' -> ['',3] -> SUCCESS
TEST: '( (fn* (a b) (+ b a)) 3 4)' -> ['',7] -> SUCCESS
TEST: '( (fn* () 4) )' -> ['',4] -> SUCCESS
TEST: '( (fn* (f x) (f x)) (fn* (a) (+ 1 a)) 7)' -> ['',8] -> SUCCESS
Testing closures
TEST: '( ( (fn* (a) (fn* (b) (+ a b))) 5) 7)' -> ['',12] -> SUCCESS
TEST: '(def! gen-plus5 (fn* () (fn* (b) (+ 5 b))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus5 (gen-plus5))' -> ['',] -> SUCCESS (result ignored)
TEST: '(plus5 7)' -> ['',12] -> SUCCESS
TEST: '(def! gen-plusX (fn* (x) (fn* (b) (+ x b))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus7 (gen-plusX 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(plus7 8)' -> ['',15] -> SUCCESS
Testing do form
TEST: '(do (prn 101))' -> ['101\n',nil] -> SUCCESS
TEST: '(do (prn 102) 7)' -> ['102\n',7] -> SUCCESS
TEST: '(do (prn 101) (prn 102) (+ 1 2))' -> ['101\n102\n',3] -> SUCCESS
TEST: '(do (def! a 6) 7 (+ a 8))' -> ['',14] -> SUCCESS
TEST: 'a' -> ['',6] -> SUCCESS
Testing special form case-sensitivity
TEST: '(def! DO (fn* (a) 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(DO 3)' -> ['',7] -> SUCCESS
Testing recursive sumdown function
TEST: '(def! sumdown (fn* (N) (if (> N 0) (+ N (sumdown  (- N 1))) 0)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(sumdown 1)' -> ['',1] -> SUCCESS
TEST: '(sumdown 2)' -> ['',3] -> SUCCESS
TEST: '(sumdown 6)' -> ['',21] -> SUCCESS
Testing recursive fibonacci function
TEST: '(def! fib (fn* (N) (if (= N 0) 1 (if (= N 1) 1 (+ (fib (- N 1)) (fib (- N 2)))))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(fib 1)' -> ['',1] -> SUCCESS
TEST: '(fib 2)' -> ['',2] -> SUCCESS
TEST: '(fib 4)' -> ['',5] -> SUCCESS
Testing recursive function in environment.
TEST: '(let* (f (fn* () x) x 3) (f))' -> ['',3] -> SUCCESS
TEST: '(let* (cst (fn* (n) (if (= n 0) nil (cst (- n 1))))) (cst 1))' -> ['',nil] -> SUCCESS
TEST: '(let* (f (fn* (n) (if (= n 0) 0 (g (- n 1)))) g (fn* (n) (f n))) (f 2))' -> ['',0] -> SUCCESS

-------- Deferrable Functionality --------
Testing if on strings
TEST: '(if "" 7 8)' -> ['',7] -> SUCCESS
Testing string equality
TEST: '(= "" "")' -> ['',true] -> SUCCESS
TEST: '(= "abc" "abc")' -> ['',true] -> SUCCESS
TEST: '(= "abc" "")' -> ['',false] -> SUCCESS
TEST: '(= "" "abc")' -> ['',false] -> SUCCESS
TEST: '(= "abc" "def")' -> ['',false] -> SUCCESS
TEST: '(= "abc" "ABC")' -> ['',false] -> SUCCESS
TEST: '(= (list) "")' -> ['',false] -> SUCCESS
TEST: '(= "" (list))' -> ['',false] -> SUCCESS
Testing variable length arguments
TEST: '( (fn* (& more) (count more)) 1 2 3)' -> ['',3] -> SUCCESS
TEST: '( (fn* (& more) (list? more)) 1 2 3)' -> ['',true] -> SUCCESS
TEST: '( (fn* (& more) (count more)) 1)' -> ['',1] -> SUCCESS
TEST: '( (fn* (& more) (count more)) )' -> ['',0] -> SUCCESS
TEST: '( (fn* (& more) (list? more)) )' -> ['',true] -> SUCCESS
TEST: '( (fn* (a & more) (count more)) 1 2 3)' -> ['',2] -> SUCCESS
TEST: '( (fn* (a & more) (count more)) 1)' -> ['',0] -> SUCCESS
TEST: '( (fn* (a & more) (list? more)) 1)' -> ['',true] -> SUCCESS
Testing language defined not function
TEST: '(not false)' -> ['',true] -> SUCCESS
TEST: '(not nil)' -> ['',true] -> SUCCESS
TEST: '(not true)' -> ['',false] -> SUCCESS
TEST: '(not "a")' -> ['',false] -> SUCCESS
TEST: '(not 0)' -> ['',false] -> SUCCESS
-----------------------------------------------------
Testing string quoting
TEST: '""' -> ['',""] -> SUCCESS
TEST: '"abc"' -> ['',"abc"] -> SUCCESS
TEST: '"abc  def"' -> ['',"abc  def"] -> SUCCESS
TEST: '"\\""' -> ['',"\""] -> SUCCESS
TEST: '"abc\\ndef\\nghi"' -> ['',"abc\ndef\nghi"] -> SUCCESS
TEST: '"abc\\\\def\\\\ghi"' -> ['',"abc\\def\\ghi"] -> SUCCESS
TEST: '"\\\\n"' -> ['',"\\n"] -> SUCCESS
Testing pr-str
TEST: '(pr-str)' -> ['',""] -> SUCCESS
TEST: '(pr-str "")' -> ['',"\"\""] -> SUCCESS
TEST: '(pr-str "abc")' -> ['',"\"abc\""] -> SUCCESS
TEST: '(pr-str "abc  def" "ghi jkl")' -> ['',"\"abc  def\" \"ghi jkl\""] -> SUCCESS
TEST: '(pr-str "\\"")' -> ['',"\"\\\"\""] -> SUCCESS
TEST: '(pr-str (list 1 2 "abc" "\\"") "def")' -> ['',"(1 2 \"abc\" \"\\\"\") \"def\""] -> SUCCESS
TEST: '(pr-str "abc\\ndef\\nghi")' -> ['',"\"abc\\ndef\\nghi\""] -> SUCCESS
TEST: '(pr-str "abc\\\\def\\\\ghi")' -> ['',"\"abc\\\\def\\\\ghi\""] -> SUCCESS
TEST: '(pr-str (list))' -> ['',"()"] -> SUCCESS
Testing str
TEST: '(str)' -> ['',""] -> SUCCESS
TEST: '(str "")' -> ['',""] -> SUCCESS
TEST: '(str "abc")' -> ['',"abc"] -> SUCCESS
TEST: '(str "\\"")' -> ['',"\""] -> SUCCESS
TEST: '(str 1 "abc" 3)' -> ['',"1abc3"] -> SUCCESS
TEST: '(str "abc  def" "ghi jkl")' -> ['',"abc  defghi jkl"] -> SUCCESS
TEST: '(str "abc\\ndef\\nghi")' -> ['',"abc\ndef\nghi"] -> SUCCESS
TEST: '(str "abc\\\\def\\\\ghi")' -> ['',"abc\\def\\ghi"] -> SUCCESS
TEST: '(str (list 1 2 "abc" "\\"") "def")' -> ['',"(1 2 abc \")def"] -> SUCCESS
TEST: '(str (list))' -> ['',"()"] -> SUCCESS
Testing prn
TEST: '(prn)' -> ['\n',nil] -> SUCCESS
TEST: '(prn "")' -> ['""\n',nil] -> SUCCESS
TEST: '(prn "abc")' -> ['"abc"\n',nil] -> SUCCESS
TEST: '(prn "abc  def" "ghi jkl")' -> ['"abc  def" "ghi jkl"',] -> SUCCESS
TEST: '(prn "\\"")' -> ['"\\\\""\n',nil] -> SUCCESS
TEST: '(prn "abc\\ndef\\nghi")' -> ['"abc\\\\ndef\\\\nghi"\n',nil] -> SUCCESS
TEST: '(prn "abc\\\\def\\\\ghi")' -> ['"abc\\\\\\\\def\\\\\\\\ghi"',] -> SUCCESS
TEST: 'nil' -> ['',] -> SUCCESS (result ignored)
TEST: '(prn (list 1 2 "abc" "\\"") "def")' -> ['\\(1 2 "abc" "\\\\""\\) "def"\n',nil] -> SUCCESS
Testing println
TEST: '(println)' -> ['\n',nil] -> SUCCESS
TEST: '(println "")' -> ['\n',nil] -> SUCCESS
TEST: '(println "abc")' -> ['abc\n',nil] -> SUCCESS
TEST: '(println "abc  def" "ghi jkl")' -> ['abc  def ghi jkl',] -> SUCCESS
TEST: '(println "\\"")' -> ['"\n',nil] -> SUCCESS
TEST: '(println "abc\\ndef\\nghi")' -> ['abc\ndef\nghi\n',nil] -> SUCCESS
TEST: '(println "abc\\\\def\\\\ghi")' -> ['abc\\\\def\\\\ghi\n',nil] -> SUCCESS
TEST: '(println (list 1 2 "abc" "\\"") "def")' -> ['\\(1 2 abc "\\) def\n',nil] -> SUCCESS
Testing keywords
TEST: '(= abc: abc:)' -> ['',true] -> SUCCESS
TEST: '(= abc: def:)' -> ['',false] -> SUCCESS
TEST: '(= abc: "abc:")' -> ['',false] -> SUCCESS
TEST: '(= (list abc:) (list abc:))' -> ['',true] -> SUCCESS
Testing vector truthiness
TEST: '(if [] 7 8)' -> ['',7] -> SUCCESS
Testing vector printing
TEST: '(pr-str [1 2 "abc" "\\""] "def")' -> ['',"[1 2 \"abc\" \"\\\"\"] \"def\""] -> SUCCESS
TEST: '(pr-str [])' -> ['',"[]"] -> SUCCESS
TEST: '(str [1 2 "abc" "\\""] "def")' -> ['',"[1 2 abc \"]def"] -> SUCCESS
TEST: '(str [])' -> ['',"[]"] -> SUCCESS
Testing vector functions
TEST: '(count [1 2 3])' -> ['',3] -> SUCCESS
TEST: '(empty? [1 2 3])' -> ['',false] -> SUCCESS
TEST: '(empty? [])' -> ['',true] -> SUCCESS
TEST: '(list? [4 5 6])' -> ['',false] -> SUCCESS
Testing vector equality
TEST: '(= [] (list))' -> ['',true] -> SUCCESS
TEST: '(= [7 8] [7 8])' -> ['',true] -> SUCCESS
TEST: '(= [abc:] [abc:])' -> ['',true] -> SUCCESS
TEST: '(= (list 1 2) [1 2])' -> ['',true] -> SUCCESS
TEST: '(= (list 1) [])' -> ['',false] -> SUCCESS
TEST: '(= [] [1])' -> ['',false] -> SUCCESS
TEST: '(= 0 [])' -> ['',false] -> SUCCESS
TEST: '(= [] 0)' -> ['',false] -> SUCCESS
TEST: '(= [] "")' -> ['',false] -> SUCCESS
TEST: '(= "" [])' -> ['',false] -> SUCCESS
Testing vector parameter lists
TEST: '( (fn* [] 4) )' -> ['',4] -> SUCCESS
TEST: '( (fn* [f x] (f x)) (fn* [a] (+ 1 a)) 7)' -> ['',8] -> SUCCESS
Nested vector/list equality
TEST: '(= [(list)] (list []))' -> ['',true] -> SUCCESS
TEST: '(= [1 2 (list 3 4 [5 6])] (list 1 2 [3 4 (list 5 6)]))' -> ['',true] -> SUCCESS

TEST RESULTS (for ./tests/mal/step4_if_fn_do.mal):
    0: soft failing tests
    0: failing tests
  178: passing tests
  178: total tests

----------------------------------------------
Testing recursive tail-call function
TEST: '(def! sum2 (fn* (n acc) (if (= n 0) acc (sum2 (- n 1) (+ n acc)))))' -> ['',] -> SUCCESS (result ignored)
TODO: test let*, and do for TCO
TEST: '(sum2 10 0)' -> ['',55] -> SUCCESS
TEST: '(def! res2 nil)' -> ['',nil] -> SUCCESS
TEST: '(def! res2 (sum2 10000 0))' -> ['',] -> SUCCESS (result ignored)
TEST: 'res2' -> ['',50005000] -> SUCCESS
Test mutually recursive tail-call functions
TEST: '(def! foo (fn* (n) (if (= n 0) 0 (bar (- n 1)))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! bar (fn* (n) (if (= n 0) 0 (foo (- n 1)))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(foo 10000)' -> ['',0] -> SUCCESS

TEST RESULTS (for ./tests/mal/step5_tco.mal):
    0: soft failing tests
    0: failing tests
    8: passing tests
    8: total tests

----------------------------------------------

Testing that (do (do)) not broken by TCO
TEST: '(do (do 1 2))' -> ['',2] -> SUCCESS

Testing read-string, eval and slurp
TEST: '(read-string "(1 2 (3 4) nil)")' -> ['',(1 2 (3 4) nil)] -> SUCCESS
TEST: '(= nil (read-string "nil"))' -> ['',true] -> SUCCESS
TEST: '(read-string "(+ 2 3)")' -> ['',(+ 2 3)] -> SUCCESS
TEST: '(read-string "\\"\\n\\"")' -> ['',"\n"] -> SUCCESS
TEST: '(read-string "7 ;; comment")' -> ['',7] -> SUCCESS
TEST: '(read-string ";; comment")' -> ['',] -> SUCCESS (result ignored)
TEST: '(eval (read-string "(+ 2 3)"))' -> ['',5] -> SUCCESS
TEST: '(slurp "./tests/fixtures/test.txt")' -> ['',"A line of text\n"] -> SUCCESS
TEST: '(slurp "./tests/fixtures/test.txt")' -> ['',"A line of text\n"] -> SUCCESS
Testing load-file
TEST: '(load-file "./tests/fixtures/inc.mal")' -> ['',nil] -> SUCCESS
TEST: '(inc1 7)' -> ['',8] -> SUCCESS
TEST: '(inc2 7)' -> ['',9] -> SUCCESS
TEST: '(inc3 9)' -> ['',12] -> SUCCESS

Testing atoms
TEST: '(def! inc3 (fn* (a) (+ 3 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! a (atom 2))' -> ['',(atom 2)] -> SUCCESS
TEST: '(atom? a)' -> ['',true] -> SUCCESS
TEST: '(atom? 1)' -> ['',false] -> SUCCESS
TEST: '(deref a)' -> ['',2] -> SUCCESS
TEST: '(reset! a 3)' -> ['',3] -> SUCCESS
TEST: '(deref a)' -> ['',3] -> SUCCESS
TEST: '(swap! a inc3)' -> ['',6] -> SUCCESS
TEST: '(deref a)' -> ['',6] -> SUCCESS
TEST: '(swap! a (fn* (a) a))' -> ['',6] -> SUCCESS
TEST: '(swap! a (fn* (a) (* 2 a)))' -> ['',12] -> SUCCESS
TEST: '(swap! a (fn* (a b) (* a b)) 10)' -> ['',120] -> SUCCESS
TEST: '(swap! a + 3)' -> ['',123] -> SUCCESS
Testing swap!/closure interaction
TEST: '(def! inc-it (fn* (a) (+ 1 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! atm (atom 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! f (fn* () (swap! atm inc-it)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(f)' -> ['',8] -> SUCCESS
TEST: '(f)' -> ['',9] -> SUCCESS
Testing whether closures can retain atoms
TEST: '(def! g (let* (atm (atom 0)) (fn* () (deref atm))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! atm (atom 1))' -> ['',] -> SUCCESS (result ignored)
TEST: '(g)' -> ['',0] -> SUCCESS

-------- Deferrable Functionality --------
Testing reading of large files
TEST: '(load-file "./tests/fixtures/computations.mal")' -> ['',nil] -> SUCCESS
TEST: '(sumdown 2)' -> ['',3] -> SUCCESS
TEST: '(fib 2)' -> ['',1] -> SUCCESS
Testing `@` reader macro (short for `deref`)
TEST: '(def! atm (atom 9))' -> ['',] -> SUCCESS (result ignored)
TEST: '@atm' -> ['',9] -> SUCCESS
Testing that vector params not broken by TCO
TEST: '(def! g (fn* [] 78))' -> ['',] -> SUCCESS (result ignored)
TEST: '(g)' -> ['',78] -> SUCCESS
TEST: '(def! g (fn* [a] (+ a 78)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(g 3)' -> ['',81] -> SUCCESS

Testing that *ARGV* exists and is an empty list
TEST: '(list? *ARGV*)' -> ['',true] -> SUCCESS
TEST: '*ARGV*' -> ['',()] -> SUCCESS

Testing that eval sets aa in root scope, and that it is found in nested scope
TEST: '(let* (b 12) (do (eval (read-string "(def! aa 7)")) aa ))' -> ['',7] -> SUCCESS

-------- Optional Functionality --------
Testing comments in a file
TEST: '(load-file "./tests/fixtures/incB.mal")' -> ['',nil] -> SUCCESS
TEST: '(inc4 7)' -> ['',11] -> SUCCESS
TEST: '(inc5 7)' -> ['',12] -> SUCCESS
Testing map literal across multiple lines in a file
TEST: '(load-file "./tests/fixtures/incC.mal")' -> ['',nil] -> SUCCESS
TEST: 'mymap' -> ['',{"a" 1}] -> SUCCESS
Checking that eval does not use local environments.
TEST: '(def! a 1)' -> ['',1] -> SUCCESS
TEST: '(let* (a 2) (eval (read-string "a")))' -> ['',1] -> SUCCESS
Non alphanumeric characters in comments in read-string
TEST: '(read-string "1;!")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\"")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;#")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;$")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;%")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\'")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\\\")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\\\\\\\")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\\\\\\\\\\\")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;`")' -> ['',1] -> SUCCESS
TEST: '(read-string "1; &()*+,-./:;<=>?@[]^_{|}~")' -> ['',1] -> SUCCESS

TEST RESULTS (for ./tests/mal/step6_file.mal):
    0: soft failing tests
    0: failing tests
   65: passing tests
   65: total tests

----------------------------------------------
Testing cons function
TEST: '(cons 1 (list))' -> ['',(1)] -> SUCCESS
TEST: '(cons 1 (list 2))' -> ['',(1 2)] -> SUCCESS
TEST: '(cons 1 (list 2 3))' -> ['',(1 2 3)] -> SUCCESS
TEST: '(cons (list 1) (list 2 3))' -> ['',((1) 2 3)] -> SUCCESS
TEST: '(def! a (list 2 3))' -> ['',] -> SUCCESS (result ignored)
TEST: '(cons 1 a)' -> ['',(1 2 3)] -> SUCCESS
TEST: 'a' -> ['',(2 3)] -> SUCCESS
Testing concat function
TEST: '(concat)' -> ['',()] -> SUCCESS
TEST: '(concat (list 1 2))' -> ['',(1 2)] -> SUCCESS
TEST: '(concat (list 1 2) (list 3 4))' -> ['',(1 2 3 4)] -> SUCCESS
TEST: '(concat (list 1 2) (list 3 4) (list 5 6))' -> ['',(1 2 3 4 5 6)] -> SUCCESS
TEST: '(concat (concat))' -> ['',()] -> SUCCESS
TEST: '(concat (list) (list))' -> ['',()] -> SUCCESS
TEST: '(= () (concat))' -> ['',true] -> SUCCESS
TEST: '(def! a (list 1 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! b (list 3 4))' -> ['',] -> SUCCESS (result ignored)
TEST: '(concat a b (list 5 6))' -> ['',(1 2 3 4 5 6)] -> SUCCESS
TEST: 'a' -> ['',(1 2)] -> SUCCESS
TEST: 'b' -> ['',(3 4)] -> SUCCESS
Testing regular quote
TEST: '(quote 7)' -> ['',7] -> SUCCESS
TEST: '(quote (1 2 3))' -> ['',(1 2 3)] -> SUCCESS
TEST: '(quote (1 2 (3 4)))' -> ['',(1 2 (3 4))] -> SUCCESS
Testing simple quasiquote
TEST: '(quasiquote nil)' -> ['',nil] -> SUCCESS
TEST: '(quasiquote 7)' -> ['',7] -> SUCCESS
TEST: '(quasiquote a)' -> ['',a] -> SUCCESS
TEST: '(quasiquote {"a" b})' -> ['',{"a" b}] -> SUCCESS
Testing quasiquote with lists
TEST: '(quasiquote ())' -> ['',()] -> SUCCESS
TEST: '(quasiquote (1 2 3))' -> ['',(1 2 3)] -> SUCCESS
TEST: '(quasiquote (a))' -> ['',(a)] -> SUCCESS
TEST: '(quasiquote (1 2 (3 4)))' -> ['',(1 2 (3 4))] -> SUCCESS
TEST: '(quasiquote (nil))' -> ['',(nil)] -> SUCCESS
TEST: '(quasiquote (1 ()))' -> ['',(1 ())] -> SUCCESS
TEST: '(quasiquote (() 1))' -> ['',(() 1)] -> SUCCESS
TEST: '(quasiquote (1 () 2))' -> ['',(1 () 2)] -> SUCCESS
TEST: '(quasiquote (()))' -> ['',(())] -> SUCCESS
(quasiquote (f () g (h) i (j k) l))
=>(f () g (h) i (j k) l)
Testing unquote
TEST: '(quasiquote (unquote 7))' -> ['',7] -> SUCCESS
TEST: '(def! a 8)' -> ['',8] -> SUCCESS
TEST: '(quasiquote a)' -> ['',a] -> SUCCESS
TEST: '(quasiquote (unquote a))' -> ['',8] -> SUCCESS
TEST: '(quasiquote (1 a 3))' -> ['',(1 a 3)] -> SUCCESS
TEST: '(quasiquote (1 (unquote a) 3))' -> ['',(1 8 3)] -> SUCCESS
TEST: '(def! b (quote (1 "b" "d")))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '(quasiquote (1 b 3))' -> ['',(1 b 3)] -> SUCCESS
TEST: '(quasiquote (1 (unquote b) 3))' -> ['',(1 (1 "b" "d") 3)] -> SUCCESS
TEST: '(quasiquote ((unquote 1) (unquote 2)))' -> ['',(1 2)] -> SUCCESS
Quasiquote and environments
TEST: '(let* (x 0) (quasiquote (unquote x)))' -> ['',0] -> SUCCESS
Testing splice-unquote
TEST: '(def! c (quote (1 "b" "d")))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '(quasiquote (1 c 3))' -> ['',(1 c 3)] -> SUCCESS
TEST: '(quasiquote (1 (splice-unquote c) 3))' -> ['',(1 1 "b" "d" 3)] -> SUCCESS
TEST: '(quasiquote (1 (splice-unquote c)))' -> ['',(1 1 "b" "d")] -> SUCCESS
TEST: '(quasiquote ((splice-unquote c) 2))' -> ['',(1 "b" "d" 2)] -> SUCCESS
TEST: '(quasiquote ((splice-unquote c) (splice-unquote c)))' -> ['',(1 "b" "d" 1 "b" "d")] -> SUCCESS
Testing symbol equality
TEST: '(= (quote abc) (quote abc))' -> ['',true] -> SUCCESS
TEST: '(= (quote abc) (quote abcd))' -> ['',false] -> SUCCESS
TEST: '(= (quote abc) "abc")' -> ['',false] -> SUCCESS
TEST: '(= "abc" (quote abc))' -> ['',false] -> SUCCESS
TEST: '(= "abc" (str (quote abc)))' -> ['',true] -> SUCCESS
TEST: '(= (quote abc) nil)' -> ['',false] -> SUCCESS
TEST: '(= nil (quote abc))' -> ['',false] -> SUCCESS

-------- Deferrable Functionality --------
Testing ' (quote) reader macro
TEST: "'7" -> ['',7] -> SUCCESS
TEST: "'(1 2 3)" -> ['',(1 2 3)] -> SUCCESS
TEST: "'(1 2 (3 4))" -> ['',(1 2 (3 4))] -> SUCCESS
Testing cons and concat with vectors
TEST: '(cons 1 [])' -> ['',(1)] -> SUCCESS
TEST: '(cons [1] [2 3])' -> ['',([1] 2 3)] -> SUCCESS
TEST: '(cons 1 [2 3])' -> ['',(1 2 3)] -> SUCCESS
TEST: '(concat [1 2] (list 3 4) [5 6])' -> ['',(1 2 3 4 5 6)] -> SUCCESS
TEST: '(concat [1 2])' -> ['',(1 2)] -> SUCCESS

-------- Optional Functionality --------
Testing ` (quasiquote) reader macro
TEST: '`7' -> ['',7] -> SUCCESS
TEST: '`(1 2 3)' -> ['',(1 2 3)] -> SUCCESS
TEST: '`(1 2 (3 4))' -> ['',(1 2 (3 4))] -> SUCCESS
TEST: '`(nil)' -> ['',(nil)] -> SUCCESS
Testing ~ (unquote) reader macro
TEST: '`~7' -> ['',7] -> SUCCESS
TEST: '(def! a 8)' -> ['',8] -> SUCCESS
TEST: '`(1 ~a 3)' -> ['',(1 8 3)] -> SUCCESS
TEST: '(def! b \'(1 "b" "d"))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '`(1 b 3)' -> ['',(1 b 3)] -> SUCCESS
TEST: '`(1 ~b 3)' -> ['',(1 (1 "b" "d") 3)] -> SUCCESS
Testing ~@ (splice-unquote) reader macro
TEST: '(def! c \'(1 "b" "d"))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '`(1 c 3)' -> ['',(1 c 3)] -> SUCCESS
TEST: '`(1 ~@c 3)' -> ['',(1 1 "b" "d" 3)] -> SUCCESS
Testing vec function
TEST: '(vec (list))' -> ['',[]] -> SUCCESS
TEST: '(vec (list 1))' -> ['',[1]] -> SUCCESS
TEST: '(vec (list 1 2))' -> ['',[1 2]] -> SUCCESS
TEST: '(vec [])' -> ['',[]] -> SUCCESS
TEST: '(vec [1 2])' -> ['',[1 2]] -> SUCCESS
Testing that vec does not mutate the original list
TEST: '(def! a (list 1 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(vec a)' -> ['',[1 2]] -> SUCCESS
TEST: 'a' -> ['',(1 2)] -> SUCCESS
Test quine
TEST: '((fn* (q) (quasiquote ((unquote q) (quote (unquote q))))) (quote (fn* (q) (quasiquote ((unquote q) (quote (unquote q)))))))' -> ['',((fn* (q) (quasiquote ((unquote q) (quote (unquote q))))) (quote (fn* (q) (quasiquote ((unquote q) (quote (unquote q)))))))] -> SUCCESS
Testing quasiquote with vectors
TEST: '(quasiquote [])' -> ['',[]] -> SUCCESS
TEST: '(quasiquote [[]])' -> ['',[[]]] -> SUCCESS
TEST: '(quasiquote [()])' -> ['',[()]] -> SUCCESS
TEST: '(quasiquote ([]))' -> ['',([])] -> SUCCESS
TEST: '(def! a 8)' -> ['',8] -> SUCCESS
TEST: '`[1 a 3]' -> ['',[1 a 3]] -> SUCCESS
TEST: '(quasiquote [a [] b [c] d [e f] g])' -> ['',[a [] b [c] d [e f] g]] -> SUCCESS
Testing unquote with vectors
TEST: '`[~a]' -> ['',[8]] -> SUCCESS
TEST: '`[(~a)]' -> ['',[(8)]] -> SUCCESS
TEST: '`([~a])' -> ['',([8])] -> SUCCESS
TEST: '`[a ~a a]' -> ['',[a 8 a]] -> SUCCESS
TEST: '`([a ~a a])' -> ['',([a 8 a])] -> SUCCESS
TEST: '`[(a ~a a)]' -> ['',[(a 8 a)]] -> SUCCESS
Testing splice-unquote with vectors
TEST: '(def! c \'(1 "b" "d"))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '`[~@c]' -> ['',[1 "b" "d"]] -> SUCCESS
TEST: '`[(~@c)]' -> ['',[(1 "b" "d")]] -> SUCCESS
TEST: '`([~@c])' -> ['',([1 "b" "d"])] -> SUCCESS
TEST: '`[1 ~@c 3]' -> ['',[1 1 "b" "d" 3]] -> SUCCESS
TEST: '`([1 ~@c 3])' -> ['',([1 1 "b" "d" 3])] -> SUCCESS
TEST: '`[(1 ~@c 3)]' -> ['',[(1 1 "b" "d" 3)]] -> SUCCESS
Misplaced unquote or splice-unquote
TEST: '`(0 unquote)' -> ['',(0 unquote)] -> SUCCESS
TEST: '`(0 splice-unquote)' -> ['',(0 splice-unquote)] -> SUCCESS
TEST: '`[unquote 0]' -> ['',[unquote 0]] -> SUCCESS
TEST: '`[splice-unquote 0]' -> ['',[splice-unquote 0]] -> SUCCESS
Debugging quasiquote
TEST: '(quasiquoteexpand nil)' -> ['',nil] -> SUCCESS
TEST: '(quasiquoteexpand 7)' -> ['',7] -> SUCCESS
TEST: '(quasiquoteexpand a)' -> ['',(quote a)] -> SUCCESS
TEST: '(quasiquoteexpand {"a" b})' -> ['',(quote {"a" b})] -> SUCCESS
TEST: '(quasiquoteexpand ())' -> ['',()] -> SUCCESS
TEST: '(quasiquoteexpand (1 2 3))' -> ['',(cons 1 (cons 2 (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (a))' -> ['',(cons (quote a) ())] -> SUCCESS
TEST: '(quasiquoteexpand (1 2 (3 4)))' -> ['',(cons 1 (cons 2 (cons (cons 3 (cons 4 ())) ())))] -> SUCCESS
TEST: '(quasiquoteexpand (nil))' -> ['',(cons nil ())] -> SUCCESS
TEST: '(quasiquoteexpand (1 ()))' -> ['',(cons 1 (cons () ()))] -> SUCCESS
TEST: '(quasiquoteexpand (() 1))' -> ['',(cons () (cons 1 ()))] -> SUCCESS
TEST: '(quasiquoteexpand (1 () 2))' -> ['',(cons 1 (cons () (cons 2 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (()))' -> ['',(cons () ())] -> SUCCESS
TEST: '(quasiquoteexpand (f () g (h) i (j k) l))' -> ['',(cons (quote f) (cons () (cons (quote g) (cons (cons (quote h) ()) (cons (quote i) (cons (cons (quote j) (cons (quote k) ())) (cons (quote l) ())))))))] -> SUCCESS
TEST: '(quasiquoteexpand (unquote 7))' -> ['',7] -> SUCCESS
TEST: '(quasiquoteexpand a)' -> ['',(quote a)] -> SUCCESS
TEST: '(quasiquoteexpand (unquote a))' -> ['',a] -> SUCCESS
TEST: '(quasiquoteexpand (1 a 3))' -> ['',(cons 1 (cons (quote a) (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (1 (unquote a) 3))' -> ['',(cons 1 (cons a (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (1 b 3))' -> ['',(cons 1 (cons (quote b) (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (1 (unquote b) 3))' -> ['',(cons 1 (cons b (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand ((unquote 1) (unquote 2)))' -> ['',(cons 1 (cons 2 ()))] -> SUCCESS
TEST: '(quasiquoteexpand (a (splice-unquote (b c)) d))' -> ['',(cons (quote a) (concat (b c) (cons (quote d) ())))] -> SUCCESS
TEST: '(quasiquoteexpand (1 c 3))' -> ['',(cons 1 (cons (quote c) (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (1 (splice-unquote c) 3))' -> ['',(cons 1 (concat c (cons 3 ())))] -> SUCCESS
TEST: '(quasiquoteexpand (1 (splice-unquote c)))' -> ['',(cons 1 (concat c ()))] -> SUCCESS
TEST: '(quasiquoteexpand ((splice-unquote c) 2))' -> ['',(concat c (cons 2 ()))] -> SUCCESS
TEST: '(quasiquoteexpand ((splice-unquote c) (splice-unquote c)))' -> ['',(concat c (concat c ()))] -> SUCCESS
TEST: '(quasiquoteexpand [])' -> ['',(vec ())] -> SUCCESS
TEST: '(quasiquoteexpand [[]])' -> ['',(vec (cons (vec ()) ()))] -> SUCCESS
TEST: '(quasiquoteexpand [()])' -> ['',(vec (cons () ()))] -> SUCCESS
TEST: '(quasiquoteexpand ([]))' -> ['',(cons (vec ()) ())] -> SUCCESS
TEST: '(quasiquoteexpand [1 a 3])' -> ['',(vec (cons 1 (cons (quote a) (cons 3 ()))))] -> SUCCESS
TEST: '(quasiquoteexpand [a [] b [c] d [e f] g])' -> ['',(vec (cons (quote a) (cons (vec ()) (cons (quote b) (cons (vec (cons (quote c) ())) (cons (quote d) (cons (vec (cons (quote e) (cons (quote f) ()))) (cons (quote g) ()))))))))] -> SUCCESS

TEST RESULTS (for ./tests/mal/step7_quote.mal):
    0: soft failing tests
    0: failing tests
  147: passing tests
  147: total tests

----------------------------------------------
Testing trivial macros
TEST: '(defmacro! one (fn* () 1))' -> ['',] -> SUCCESS (result ignored)
TEST: '(one)' -> ['',1] -> SUCCESS
TEST: '(defmacro! two (fn* () 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(two)' -> ['',2] -> SUCCESS
Testing unless macros
TEST: '(defmacro! unless (fn* (pred a b) `(if ~pred ~b ~a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(unless false 7 8)' -> ['',7] -> SUCCESS
TEST: '(unless true 7 8)' -> ['',8] -> SUCCESS
TEST: "(defmacro! unless2 (fn* (pred a b) (list 'if (list 'not pred) a b)))" -> ['',] -> SUCCESS (result ignored)
TEST: '(unless2 false 7 8)' -> ['',7] -> SUCCESS
TEST: '(unless2 true 7 8)' -> ['',8] -> SUCCESS
Testing macroexpand
TEST: '(macroexpand (one))' -> ['',1] -> SUCCESS
TEST: '(macroexpand (unless PRED A B))' -> ['',(if PRED B A)] -> SUCCESS
TEST: '(macroexpand (unless2 PRED A B))' -> ['',(if (not PRED) A B)] -> SUCCESS
TEST: '(macroexpand (unless2 2 3 4))' -> ['',(if (not 2) 3 4)] -> SUCCESS
Testing evaluation of macro result
TEST: '(defmacro! identity (fn* (x) x))' -> ['',] -> SUCCESS (result ignored)
TEST: '(let* (a 123) (macroexpand (identity a)))' -> ['',a] -> SUCCESS
TEST: '(let* (a 123) (identity a))' -> ['',123] -> SUCCESS
Test that macros do not break empty list
TEST: '()' -> ['',()] -> SUCCESS
Test that macros do not break quasiquote
TEST: '`(1)' -> ['',(1)] -> SUCCESS

-------- Deferrable Functionality --------
Testing non-macro function
TEST: '(not (= 1 1))' -> ['',false] -> SUCCESS
TEST: '(not (= 1 2))' -> ['',true] -> SUCCESS
Testing nth, first and rest functions
TEST: '(nth (list 1) 0)' -> ['',1] -> SUCCESS
TEST: '(nth (list 1 2) 1)' -> ['',2] -> SUCCESS
TEST: '(nth (list 1 2 nil) 2)' -> ['',nil] -> SUCCESS
TEST: '(def! x "x")' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! x (nth (list 1 2) 2))' -> ['',] -> SUCCESS (result ignored)
TEST: 'x' -> ['',"x"] -> SUCCESS
TEST: '(first (list))' -> ['',nil] -> SUCCESS
TEST: '(first (list 6))' -> ['',6] -> SUCCESS
TEST: '(first (list 7 8 9))' -> ['',7] -> SUCCESS
TEST: '(rest (list))' -> ['',()] -> SUCCESS
TEST: '(rest (list 6))' -> ['',()] -> SUCCESS
TEST: '(rest (list 7 8 9))' -> ['',(8 9)] -> SUCCESS
Testing cond macro
TEST: '(macroexpand (cond))' -> ['',nil] -> SUCCESS
TEST: '(cond)' -> ['',nil] -> SUCCESS
TEST: '(macroexpand (cond X Y))' -> ['',(if X Y (cond))] -> SUCCESS
TEST: '(cond true 7)' -> ['',7] -> SUCCESS
TEST: '(cond false 7)' -> ['',nil] -> SUCCESS
TEST: '(macroexpand (cond X Y Z T))' -> ['',(if X Y (cond Z T))] -> SUCCESS
TEST: '(cond true 7 true 8)' -> ['',7] -> SUCCESS
TEST: '(cond false 7 true 8)' -> ['',8] -> SUCCESS
TEST: '(cond false 7 false 8 "else" 9)' -> ['',9] -> SUCCESS
TEST: '(cond false 7 (= 2 2) 8 "else" 9)' -> ['',8] -> SUCCESS
TEST: '(cond false 7 false 8 false 9)' -> ['',nil] -> SUCCESS
Testing EVAL in let*
TEST: '(let* (x (cond false "no" true "yes")) x)' -> ['',"yes"] -> SUCCESS
Testing nth, first, rest with vectors
TEST: '(nth [1] 0)' -> ['',1] -> SUCCESS
TEST: '(nth [1 2] 1)' -> ['',2] -> SUCCESS
TEST: '(nth [1 2 nil] 2)' -> ['',nil] -> SUCCESS
TEST: '(def! x "x")' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! x (nth [1 2] 2))' -> ['',] -> SUCCESS (result ignored)
TEST: 'x' -> ['',"x"] -> SUCCESS
TEST: '// (first [])' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>nil' -> ['',] -> SUCCESS (result ignored)
TEST: '// (first nil)' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>nil' -> ['',] -> SUCCESS (result ignored)
TEST: '// (first [10])' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>10' -> ['',] -> SUCCESS (result ignored)
TEST: '// (first [10 11 12])' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>10' -> ['',] -> SUCCESS (result ignored)
TEST: '// (rest [])' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>()' -> ['',] -> SUCCESS (result ignored)
TEST: '// (rest nil)' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>()' -> ['',] -> SUCCESS (result ignored)
TEST: '// (rest [10])' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>()' -> ['',] -> SUCCESS (result ignored)
TEST: '// (rest [10 11 12])' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>(11 12)' -> ['',] -> SUCCESS (result ignored)
TEST: '// (rest (cons 10 [11 12]))' -> ['',] -> SUCCESS (result ignored)
TEST: '// ;=>(11 12)' -> ['',] -> SUCCESS (result ignored)
Testing EVAL in vector let*
TEST: '(let* [x (cond false "no" true "yes")] x)' -> ['',"yes"] -> SUCCESS

------- Optional Functionality --------------
------- (Not needed for self-hosting) -------
Test that macros use closures
TEST: '(def! x 2)' -> ['',] -> SUCCESS (result ignored)
TEST: '(defmacro! a (fn* [] x))' -> ['',] -> SUCCESS (result ignored)
TEST: '(a)' -> ['',2] -> SUCCESS
TEST: '(let* (x 3) (a))' -> ['',2] -> SUCCESS

TEST RESULTS (for ./tests/mal/step8_macros.mal):
    0: soft failing tests
    0: failing tests
   74: passing tests
   74: total tests

----------------------------------------------

Testing throw
TEST: '(throw "err1")' -> ['.*([Ee][Rr][Rr][Oo][Rr]|[Ee]xception).*err1.*',] -> SUCCESS

Testing try*/catch*
TEST: '(try* 123 (catch* e 456))' -> ['',123] -> SUCCESS
TEST: '(try* abc (catch* exc (prn "exc is:" exc)))' -> ['"exc is:" "\'abc\' not found"\n',nil] -> SUCCESS
TEST: '(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))' -> ['"exc is:" "\'abc\' not found"\n',nil] -> SUCCESS
Make sure error from core can be caught
TEST: '(try* (nth () 1) (catch* exc (prn "exc is:" exc)))' -> ['"exc is:".*(length|range|[Bb]ounds|beyond).*\n',nil] -> SUCCESS
TEST: '(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))' -> ['"exc:" "my exception"\n',7] -> SUCCESS
Test that exception handlers get restored correctly
TEST: '(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))' -> ['',"c2"] -> SUCCESS
TEST: '(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))' -> ['',"c2"] -> SUCCESS
TEST: '(try* (map throw (list "my err")) (catch* exc exc))' -> ['',"my err"] -> SUCCESS

Testing builtin functions
TEST: "(symbol? 'abc)" -> ['',true] -> SUCCESS
TEST: '(symbol? "abc")' -> ['',false] -> SUCCESS
TEST: '(nil? nil)' -> ['',true] -> SUCCESS
TEST: '(nil? true)' -> ['',false] -> SUCCESS
TEST: '(true? true)' -> ['',true] -> SUCCESS
TEST: '(true? false)' -> ['',false] -> SUCCESS
TEST: '(true? true?)' -> ['',false] -> SUCCESS
TEST: '(false? false)' -> ['',true] -> SUCCESS
TEST: '(false? true)' -> ['',false] -> SUCCESS
Testing apply function with core functions
TEST: '(apply + (list 2 3))' -> ['',5] -> SUCCESS
TEST: '(apply + 4 (list 5))' -> ['',9] -> SUCCESS
TEST: '(apply prn (list 1 2 "3" (list)))' -> ['1 2 "3" \\(\\)\n',nil] -> SUCCESS
TEST: '(apply prn 1 2 (list "3" (list)))' -> ['1 2 "3" \\(\\)\n',nil] -> SUCCESS
TEST: '(apply list (list))' -> ['',()] -> SUCCESS
TEST: '(apply symbol? (list (quote two)))' -> ['',true] -> SUCCESS
Testing apply function with user functions
TEST: '(apply (fn* (a b) (+ a b)) (list 2 3))' -> ['',5] -> SUCCESS
TEST: '(apply (fn* (a b) (+ a b)) 4 (list 5))' -> ['',9] -> SUCCESS
Testing map function
TEST: '(def! nums (list 1 2 3))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! double (fn* (a) (* 2 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(double 3)' -> ['',6] -> SUCCESS
TEST: '(map double nums) ' -> ['',(2 4 6)] -> SUCCESS
TEST: '(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))' -> ['',(false true false)] -> SUCCESS
TEST: '(= () (map str ()))' -> ['',true] -> SUCCESS

------- Deferrable Functionality ----------
------- (Needed for self-hosting) -------
Testing symbol and keyword functions
TEST: '(symbol? abc:)' -> ['',false] -> SUCCESS
TEST: "(symbol? 'abc)" -> ['',true] -> SUCCESS
TEST: '(symbol? "abc")' -> ['',false] -> SUCCESS
TEST: '(symbol? (symbol "abc"))' -> ['',true] -> SUCCESS
TEST: '(keyword? abc:)' -> ['',true] -> SUCCESS
TEST: "(keyword? 'abc)" -> ['',false] -> SUCCESS
TEST: '(keyword? "abc")' -> ['',false] -> SUCCESS
TEST: '(keyword? "")' -> ['',false] -> SUCCESS
TEST: '(keyword? (keyword "abc"))' -> ['',true] -> SUCCESS
TEST: '(symbol "abc")' -> ['',abc] -> SUCCESS
TEST: '(keyword "abc")' -> ['',abc:] -> SUCCESS
Testing sequential? function
TEST: '(sequential? (list 1 2 3))' -> ['',true] -> SUCCESS
TEST: '(sequential? [15])' -> ['',true] -> SUCCESS
TEST: '(sequential? sequential?)' -> ['',false] -> SUCCESS
TEST: '(sequential? nil)' -> ['',false] -> SUCCESS
TEST: '(sequential? "abc")' -> ['',false] -> SUCCESS
Testing apply function with core functions and arguments in vector
TEST: '(apply + 4 [5])' -> ['',9] -> SUCCESS
TEST: '(apply prn 1 2 ["3" 4])' -> ['1 2 "3" 4\n',nil] -> SUCCESS
TEST: '(apply list [])' -> ['',()] -> SUCCESS
Testing apply function with user functions and arguments in vector
TEST: '(apply (fn* (a b) (+ a b)) [2 3])' -> ['',5] -> SUCCESS
TEST: '(apply (fn* (a b) (+ a b)) 4 [5])' -> ['',9] -> SUCCESS
Testing map function with vectors
TEST: '(map (fn* (a) (* 2 a)) [1 2 3])' -> ['',(2 4 6)] -> SUCCESS
TEST: '(map (fn* [& args] (list? args)) [1 2])' -> ['',(true true)] -> SUCCESS
Testing vector functions
TEST: '(vector? [10 11])' -> ['',true] -> SUCCESS
TEST: "(vector? '(12 13))" -> ['',false] -> SUCCESS
TEST: '(vector 3 4 5)' -> ['',[3 4 5]] -> SUCCESS
TEST: '(= [] (vector))' -> ['',true] -> SUCCESS
TEST: '(map? {})' -> ['',true] -> SUCCESS
TEST: "(map? '())" -> ['',false] -> SUCCESS
TEST: '(map? [])' -> ['',false] -> SUCCESS
TEST: "(map? 'abc)" -> ['',false] -> SUCCESS
TEST: '(map? abc:)' -> ['',false] -> SUCCESS

Testing hash-maps
TEST: '(hash-map "a" 1)' -> ['',{"a" 1}] -> SUCCESS
TEST: '{"a" 1}' -> ['',{"a" 1}] -> SUCCESS
TEST: '(assoc {} "a" 1)' -> ['',{"a" 1}] -> SUCCESS
TEST: '(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")' -> ['',1] -> SUCCESS
TEST: '(def! hm1 (hash-map))' -> ['',{}] -> SUCCESS
TEST: '(map? hm1)' -> ['',true] -> SUCCESS
TEST: '(map? 1)' -> ['',false] -> SUCCESS
TEST: '(map? "abc")' -> ['',false] -> SUCCESS
TEST: '(get nil "a")' -> ['',nil] -> SUCCESS
TEST: '(get hm1 "a")' -> ['',nil] -> SUCCESS
TEST: '(contains? hm1 "a")' -> ['',false] -> SUCCESS
TEST: '(def! hm2 (assoc hm1 "a" 1))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(get hm1 "a")' -> ['',nil] -> SUCCESS
TEST: '(contains? hm1 "a")' -> ['',false] -> SUCCESS
TEST: '(get hm2 "a")' -> ['',1] -> SUCCESS
TEST: '(contains? hm2 "a")' -> ['',true] -> SUCCESS
TEST: '(keys hm1)' -> ['',()] -> SUCCESS
TEST: '(= () (keys hm1))' -> ['',true] -> SUCCESS
TEST: '(keys hm2)' -> ['',("a")] -> SUCCESS
TEST: '(keys {"1" 1})' -> ['',("1")] -> SUCCESS
TEST: '(vals hm1)' -> ['',()] -> SUCCESS
TEST: '(= () (vals hm1))' -> ['',true] -> SUCCESS
TEST: '(vals hm2)' -> ['',(1)] -> SUCCESS
TEST: '(count (keys (assoc hm2 "b" 2 "c" 3)))' -> ['',3] -> SUCCESS
Testing keywords as hash-map keys
TEST: '(get {abc: 123} abc:)' -> ['',123] -> SUCCESS
TEST: '(contains? {abc: 123} abc:)' -> ['',true] -> SUCCESS
TEST: '(contains? {abcd: 123} abc:)' -> ['',false] -> SUCCESS
TEST: '(assoc {} bcd: 234)' -> ['',{bcd: 234}] -> SUCCESS
TEST: '(keyword? (nth (keys {abc: 123 def: 456}) 0))' -> ['',true] -> SUCCESS
TEST: '(keyword? (nth (vals {"a" abc: "b" def:}) 0))' -> ['',true] -> SUCCESS
Testing whether assoc updates properly
TEST: '(def! hm4 (assoc {a: 1 b: 2} a: 3 c: 1))' -> ['',] -> SUCCESS (result ignored)
TEST: '(get hm4 a:)' -> ['',3] -> SUCCESS
TEST: '(get hm4 b:)' -> ['',2] -> SUCCESS
TEST: '(get hm4 c:)' -> ['',1] -> SUCCESS
Testing nil as hash-map values
TEST: '(contains? {abc: nil} abc:)' -> ['',true] -> SUCCESS
TEST: '(assoc {} bcd: nil)' -> ['',{bcd: nil}] -> SUCCESS

Additional str and pr-str tests
TEST: '(str "A" {abc: "val"} "Z")' -> ['',"A{abc: val}Z"] -> SUCCESS
TEST: '(str true "." false "." nil "." keyw: "." \'symb)' -> ['',"true.false.nil.keyw:.symb"] -> SUCCESS
TEST: '(pr-str "A" {abc: "val"} "Z")' -> ['',"\"A\" {abc: \"val\"} \"Z\""] -> SUCCESS
TEST: '(pr-str true "." false "." nil "." keyw: "." \'symb)' -> ['',"true \".\" false \".\" nil \".\" keyw: \".\" symb"] -> SUCCESS
TEST: '(def! s (str {abc: "val1" def: "val2"}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(cond (= s "{abc: val1 def: val2}") true (= s "{def: val2 abc: val1}") true)' -> ['',true] -> SUCCESS
TEST: '(def! p (pr-str {abc: "val1" def: "val2"}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(cond (= p "{abc: \\"val1\\" def: \\"val2\\"}") true (= p "{def: \\"val2\\" abc: \\"val1\\"}") true)' -> ['',true] -> SUCCESS

Test extra function arguments as Mal List (bypassing TCO with apply)
TEST: '(apply (fn* (& more) (list? more)) [1 2 3])' -> ['',true] -> SUCCESS
TEST: '(apply (fn* (& more) (list? more)) [])' -> ['',true] -> SUCCESS
TEST: '(apply (fn* (a & more) (list? more)) [1])' -> ['',true] -> SUCCESS

------- Optional Functionality --------------
------- (Not needed for self-hosting) -------
Testing throwing a hash-map
TEST: '(throw {msg: "err2"})' -> ['.*([Ee][Rr][Rr][Oo][Rr]|[Ee]xception).*msg.*err2.*',] -> SUCCESS

Testing try* without catch*
TEST: '(try* xyz)' -> [".*\\'?xyz\\'? not found.*",] -> SUCCESS

Testing throwing non-strings
TEST: '(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))' -> ['"err:" \\(1 2 3\\)\n',7] -> SUCCESS

Testing dissoc
TEST: '(def! hm3 (assoc hm2 "b" 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(count (keys hm3))' -> ['',2] -> SUCCESS
TEST: '(count (vals hm3))' -> ['',2] -> SUCCESS
TEST: '(dissoc hm3 "a")' -> ['',{"b" 2}] -> SUCCESS
TEST: '(dissoc hm3 "a" "b")' -> ['',{}] -> SUCCESS
TEST: '(dissoc hm3 "a" "b" "c")' -> ['',{}] -> SUCCESS
TEST: '(count (keys hm3))' -> ['',2] -> SUCCESS
TEST: '(dissoc {cde: 345 fgh: 456} cde:)' -> ['',{fgh: 456}] -> SUCCESS
TEST: '(dissoc {cde: nil fgh: 456} cde:)' -> ['',{fgh: 456}] -> SUCCESS

Testing equality of hash-maps
TEST: '(= {} {})' -> ['',true] -> SUCCESS
TEST: '(= {} (hash-map))' -> ['',true] -> SUCCESS
TEST: '(= {a: 11 b: 22} (hash-map b: 22 a: 11))' -> ['',true] -> SUCCESS
TEST: '(= {a: 11 b: [22 33]} (hash-map b: [22 33] a: 11))' -> ['',true] -> SUCCESS
TEST: '(= {a: 11 b: {c: 33}} (hash-map b: {c: 33} a: 11))' -> ['',true] -> SUCCESS
TEST: '(= {a: 11 b: 22} (hash-map b: 23 a: 11))' -> ['',false] -> SUCCESS
TEST: '(= {a: 11 b: 22} (hash-map a: 11))' -> ['',false] -> SUCCESS
TEST: '(= {a: [11 22]} {a: (list 11 22)})' -> ['',true] -> SUCCESS
TEST: '(= {a: 11 b: 22} (list a: 11 b: 22))' -> ['',false] -> SUCCESS
TEST: '(= {} [])' -> ['',false] -> SUCCESS
TEST: '(= [] {})' -> ['',false] -> SUCCESS
TEST: '(keyword abc:)' -> ['',abc:] -> SUCCESS
TEST: '(keyword? (first (keys {"abc:" 123 "def:" 456})))' -> ['',false] -> SUCCESS
Testing that hashmaps don't alter function ast
TEST: '(def! bar (fn* [a] {foo: (get a foo:)}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(bar {foo: (fn* [x] x)})' -> ['',] -> SUCCESS (result ignored)
TEST: '(bar {foo: 3})' -> ['',] -> SUCCESS (result ignored)
shouldn't give an error

TEST RESULTS (for ./tests/mal/step9_try.mal):
    0: soft failing tests
    0: failing tests
  139: passing tests
  139: total tests

----------------------------------------------
Testing JavaScript nsInterop
TEST: '(% 7 5)' -> ['',2] -> SUCCESS
Bitwise operations
TEST: '(>> 5 2)' -> ['',1] -> SUCCESS
TEST: '(<< 5 2)' -> ['',20] -> SUCCESS
TEST: '(>>> 5 2)' -> ['',1] -> SUCCESS
TEST: '(/& 5 3)' -> ['',1] -> SUCCESS
TEST: '(/~ 5)' -> ['',-6] -> SUCCESS
TEST: '(/| 5 3)' -> ['',7] -> SUCCESS
TEST: '(/^ 5 3)' -> ['',6] -> SUCCESS
Logical operations
TEST: '(! true)' -> ['',false] -> SUCCESS
TEST: '(! false)' -> ['',true] -> SUCCESS
TEST: '(&& (> 3 0) (> -2 0))' -> ['',false] -> SUCCESS
TEST: '(|| (> 3 0) (> -2 0))' -> ['',true] -> SUCCESS
TEST: '(?? nil "foo")' -> ['',"foo"] -> SUCCESS
Increment and decrement
TEST: '(++ 1)' -> ['',[2 1]] -> SUCCESS
TEST: '(++ 1 "postfix")' -> ['',[2 1]] -> SUCCESS
TEST: '(++ 1 "prefix")' -> ['',[2 2]] -> SUCCESS
TEST: '(-- 1) ' -> ['',[0 1]] -> SUCCESS
TEST: '(-- 1 "postfix") ' -> ['',[0 1]] -> SUCCESS
TEST: '(-- 1 "prefix")' -> ['',[0 0]] -> SUCCESS
globalThis
TEST: '(getIn (global) [:Reflect :get])' -> ['',] -> SUCCESS (result ignored)

TEST RESULTS (for ./tests/stepA_mal.mal):
    0: soft failing tests
    0: failing tests
   20: passing tests
   20: total tests

----------------------------------------------

Testing readline
TEST: '(readline "mal-user> ")' -> ['',] -> SUCCESS (result ignored)
TEST: '"hello"' -> ['',"\"hello\""] -> FAIL (line 11):
    Expected : '.*\n"\\\\"hello\\\\""'
    Got      : '"hello"\n"hello"'

Testing *host-language*
TEST: '(= "something bogus" *host-language*)' -> ['',false] -> SUCCESS

------- Deferrable Functionality ----------
------- (Needed for self-hosting) -------


Testing hash-map evaluation and atoms (i.e. an env)
TEST: '(def! e (atom {"+" +}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(swap! e assoc "-" -)' -> ['',] -> SUCCESS (result ignored)
TEST: '( (get @e "+") 7 8)' -> ['',15] -> SUCCESS
TEST: '( (get @e "-") 11 8)' -> ['',3] -> SUCCESS
TEST: '(swap! e assoc "foo" (list))' -> ['',] -> SUCCESS (result ignored)
TEST: '(get @e "foo")' -> ['',()] -> SUCCESS
TEST: '(swap! e assoc "bar" \'(1 2 3))' -> ['',] -> SUCCESS (result ignored)
TEST: '(get @e "bar")' -> ['',(1 2 3)] -> SUCCESS
Testing for presence of optional functions
TEST: '(do (list time-ms string? number? seq conj meta with-meta fn?) nil)' -> ['',nil] -> SUCCESS
TEST: "(map symbol? '(nil false true))" -> ['',(false false false)] -> SUCCESS
------------------------------------------------------------------

------- Optional Functionality --------------
------- (Not needed for self-hosting) -------
Testing metadata on functions

Testing metadata on mal functions
TEST: '(meta (fn* (a) a))' -> ['',nil] -> SUCCESS
TEST: '(meta (with-meta (fn* (a) a) {"b" 1}))' -> ['',{"b" 1}] -> SUCCESS
TEST: '(meta (with-meta (fn* (a) a) "abc"))' -> ['',"abc"] -> SUCCESS
TEST: '(def! l-wm (with-meta (fn* (a) a) {"b" 2}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS
TEST: '(meta (with-meta l-wm {"new_meta" 123}))' -> ['',{"new_meta" 123}] -> SUCCESS
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS
TEST: '(def! f-wm (with-meta (fn* [a] (+ 1 a)) {"abc" 1}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta f-wm)' -> ['',{"abc" 1}] -> SUCCESS
TEST: '(meta (with-meta f-wm {"new_meta" 123}))' -> ['',{"new_meta" 123}] -> SUCCESS
TEST: '(meta f-wm)' -> ['',{"abc" 1}] -> SUCCESS
TEST: '(def! f-wm2 ^{"abc" 1} (fn* [a] (+ 1 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta f-wm2)' -> ['',{"abc" 1}] -> SUCCESS
Meta of native functions should return nil (not fail)
TEST: '(meta +)' -> ['',nil] -> SUCCESS

Make sure closures and metadata co-exist
TEST: '(def! gen-plusX (fn* (x) (with-meta (fn* (b) (+ x b)) {"meta" 1})))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus7 (gen-plusX 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus8 (gen-plusX 8))' -> ['',] -> SUCCESS (result ignored)
TEST: '(plus7 8)' -> ['',15] -> SUCCESS
TEST: '(meta plus7)' -> ['',{"meta" 1}] -> SUCCESS
TEST: '(meta plus8)' -> ['',{"meta" 1}] -> SUCCESS
TEST: '(meta (with-meta plus7 {"meta" 2}))' -> ['',{"meta" 2}] -> SUCCESS
TEST: '(meta plus8)' -> ['',{"meta" 1}] -> SUCCESS

Testing string? function
TEST: '(string? "")' -> ['',true] -> SUCCESS
TEST: "(string? 'abc)" -> ['',false] -> SUCCESS
TEST: '(string? "abc")' -> ['',true] -> SUCCESS
TEST: '(string? :abc)' -> ['',false] -> SUCCESS
TEST: '(string? (keyword "abc"))' -> ['',false] -> SUCCESS
TEST: '(string? 234)' -> ['',false] -> SUCCESS
TEST: '(string? nil)' -> ['',false] -> SUCCESS
Testing number? function
TEST: '(number? 123)' -> ['',true] -> SUCCESS
TEST: '(number? -1)' -> ['',true] -> SUCCESS
TEST: '(number? nil)' -> ['',false] -> SUCCESS
TEST: '(number? false)' -> ['',false] -> SUCCESS
TEST: '(number? "123")' -> ['',false] -> SUCCESS
TEST: '(def! add1 (fn* (x) (+ x 1)))' -> ['',] -> SUCCESS (result ignored)
Testing fn? function
TEST: '(fn? +)' -> ['',true] -> SUCCESS
TEST: '(fn? add1)' -> ['',true] -> SUCCESS
TEST: '(fn? cond)' -> ['',false] -> SUCCESS
TEST: '(fn? "+")' -> ['',false] -> SUCCESS
TEST: '(fn? :+)' -> ['',false] -> SUCCESS
TEST: '(fn? ^{"ismacro" true} (fn* () 0))' -> ['',true] -> SUCCESS
Testing macro? function
TEST: '(macro? cond)' -> ['',true] -> SUCCESS
TEST: '(macro? +)' -> ['',false] -> SUCCESS
TEST: '(macro? add1)' -> ['',false] -> SUCCESS
TEST: '(macro? "+")' -> ['',false] -> SUCCESS
TEST: '(macro? :+)' -> ['',false] -> SUCCESS
TEST: '(macro? {})' -> ['',false] -> SUCCESS

Testing conj function
TEST: '(conj (list) 1)' -> ['',(1)] -> SUCCESS
TEST: '(conj (list 1) 2)' -> ['',(2 1)] -> SUCCESS
TEST: '(conj (list 2 3) 4)' -> ['',(4 2 3)] -> SUCCESS
TEST: '(conj (list 2 3) 4 5 6)' -> ['',(6 5 4 2 3)] -> SUCCESS
TEST: '(conj (list 1) (list 2 3))' -> ['',((2 3) 1)] -> SUCCESS
TEST: '(conj [] 1)' -> ['',[1]] -> SUCCESS
TEST: '(conj [1] 2)' -> ['',[1 2]] -> SUCCESS
TEST: '(conj [2 3] 4)' -> ['',[2 3 4]] -> SUCCESS
TEST: '(conj [2 3] 4 5 6)' -> ['',[2 3 4 5 6]] -> SUCCESS
TEST: '(conj [1] [2 3])' -> ['',[1 [2 3]]] -> SUCCESS

Testing seq function
TEST: '(seq "abc")' -> ['',("a" "b" "c")] -> SUCCESS
TEST: '(apply str (seq "this is a test"))' -> ['',"this is a test"] -> SUCCESS
TEST: "(seq '(2 3 4))" -> ['',(2 3 4)] -> SUCCESS
TEST: '(seq [2 3 4])' -> ['',(2 3 4)] -> SUCCESS
TEST: '(seq "")' -> ['',nil] -> SUCCESS
TEST: "(seq '())" -> ['',nil] -> SUCCESS
TEST: '(seq [])' -> ['',nil] -> SUCCESS
TEST: '(seq nil)' -> ['',nil] -> SUCCESS

Testing metadata on collections
TEST: '(meta [1 2 3])' -> ['',nil] -> SUCCESS
TEST: '(with-meta [1 2 3] {"a" 1})' -> ['',[1 2 3]] -> SUCCESS
TEST: '(meta (with-meta [1 2 3] {"a" 1}))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(vector? (with-meta [1 2 3] {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(meta (with-meta [1 2 3] "abc"))' -> ['',"abc"] -> SUCCESS
TEST: '(with-meta [] "abc")' -> ['',[]] -> SUCCESS
TEST: '(meta (with-meta (list 1 2 3) {"a" 1}))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(list? (with-meta (list 1 2 3) {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(with-meta (list) {"a" 1})' -> ['',()] -> SUCCESS
TEST: '(empty? (with-meta (list) {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(meta (with-meta {"abc" 123} {"a" 1}))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(map? (with-meta {"abc" 123} {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(with-meta {} {"a" 1})' -> ['',{}] -> SUCCESS
TEST: '(def! l-wm (with-meta [4 5 6] {"b" 2}))' -> ['',[4 5 6]] -> SUCCESS
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS
TEST: '(meta (with-meta l-wm {"new_meta" 123}))' -> ['',{"new_meta" 123}] -> SUCCESS
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS

Testing metadata on builtin functions
TEST: '(meta +)' -> ['',nil] -> SUCCESS
TEST: '(def! f-wm3 ^{"def" 2} +)' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta f-wm3)' -> ['',{"def" 2}] -> SUCCESS
TEST: '(meta +)' -> ['',nil] -> SUCCESS
Loading sumdown from computations.mal
TEST: '(load-file "./tests/fixtures/computations.mal")' -> ['',nil] -> SUCCESS

Testing time-ms function
TEST: '(def! start-time (time-ms))' -> ['',] -> SUCCESS (result ignored)
TEST: '(= start-time 0)' -> ['',false] -> SUCCESS
TEST: '(sumdown 10) ; Waste some time' -> ['',55] -> SUCCESS
TEST: '(> (time-ms) start-time)' -> ['',true] -> SUCCESS

Test that defining a macro does not mutate an existing function.
TEST: '(def! f (fn* [x] (number? x)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(defmacro! m f)' -> ['',] -> SUCCESS (result ignored)
TEST: '(f (+ 1 1))' -> ['',true] -> SUCCESS
TEST: '(m (+ 1 1))' -> ['',false] -> SUCCESS

FAILURES:
FAILED TEST (line 11): "hello" -> ['',"\"hello\""]:
    Expected : '.*\n"\\\\"hello\\\\""'
    Got      : '"hello"\n"hello"'

TEST RESULTS (for ./tests/mal/stepA_mal.mal):
    0: soft failing tests
    1: failing tests
  107: passing tests
  108: total tests

----------------------------------------------
