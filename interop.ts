// This file is generated. Run 'deno task generate-interop' to regenerate it.
import * as types from './types.ts';
const interop = new Map<types.SymbolNode, types.FunctionNode>();

interop.set(
    new types.SymbolNode('AggregateError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(AggregateError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('AggregateError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(AggregateError, []));
    }),
);

interop.set(
    new types.SymbolNode('Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Array, []));
    }),
);

interop.set(
    new types.SymbolNode('ArrayBuffer.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(ArrayBuffer, []));
    }),
);

interop.set(
    new types.SymbolNode('AsyncDisposableStack.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(AsyncDisposableStack, []));
    }),
);

interop.set(
    new types.SymbolNode('BigInt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('BigInt64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(BigInt64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('BigInt64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(BigInt64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('BigInt64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(BigInt64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('BigUint64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(BigUint64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('BigUint64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(BigUint64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('BigUint64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(BigUint64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Boolean'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Boolean, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Boolean.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Boolean, []));
    }),
);

interop.set(
    new types.SymbolNode('DataView.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(DataView, []));
    }),
);

interop.set(
    new types.SymbolNode('Date'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Date.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Date, []));
    }),
);

interop.set(
    new types.SymbolNode('Date.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Date, []));
    }),
);

interop.set(
    new types.SymbolNode('Date.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Date, []));
    }),
);

interop.set(
    new types.SymbolNode('DisposableStack.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(DisposableStack, []));
    }),
);

interop.set(
    new types.SymbolNode('Error'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Error, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Error.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Error, []));
    }),
);

interop.set(
    new types.SymbolNode('EvalError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(EvalError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('EvalError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(EvalError, []));
    }),
);

interop.set(
    new types.SymbolNode('FinalizationRegistry.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(FinalizationRegistry, []));
    }),
);

interop.set(
    new types.SymbolNode('Float32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Float32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Float32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Float32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Float32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Float32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Float64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Float64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Float64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Float64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Float64Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Float64Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Function'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Function, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Function.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Function, []));
    }),
);

interop.set(
    new types.SymbolNode('Int16Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int16Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int16Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int16Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int16Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int16Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int8Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int8Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int8Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int8Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Int8Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Int8Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Map.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Map, []));
    }),
);

interop.set(
    new types.SymbolNode('Map.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Map, []));
    }),
);

interop.set(
    new types.SymbolNode('Number'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Number, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Number.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Number, []));
    }),
);

interop.set(
    new types.SymbolNode('Object'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Object, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Object'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Object, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('Object.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Object, []));
    }),
);

interop.set(
    new types.SymbolNode('Promise.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Promise, []));
    }),
);

interop.set(
    new types.SymbolNode('Proxy.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Proxy, []));
    }),
);

interop.set(
    new types.SymbolNode('RangeError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(RangeError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('RangeError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(RangeError, []));
    }),
);

interop.set(
    new types.SymbolNode('ReferenceError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(ReferenceError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('ReferenceError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(ReferenceError, []));
    }),
);

interop.set(
    new types.SymbolNode('RegExp'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(RegExp, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('RegExp'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(RegExp, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('RegExp.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(RegExp, []));
    }),
);

interop.set(
    new types.SymbolNode('RegExp.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(RegExp, []));
    }),
);

interop.set(
    new types.SymbolNode('Set.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Set, []));
    }),
);

interop.set(
    new types.SymbolNode('SharedArrayBuffer.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(SharedArrayBuffer, []));
    }),
);

interop.set(
    new types.SymbolNode('String'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('String.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(String, []));
    }),
);

interop.set(
    new types.SymbolNode('SuppressedError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(SuppressedError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('SuppressedError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(SuppressedError, []));
    }),
);

interop.set(
    new types.SymbolNode('Symbol'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Symbol, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('SyntaxError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(SyntaxError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('SyntaxError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(SyntaxError, []));
    }),
);

interop.set(
    new types.SymbolNode('TypeError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(TypeError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('TypeError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(TypeError, []));
    }),
);

interop.set(
    new types.SymbolNode('URIError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(URIError, undefined, []));
    }),
);

interop.set(
    new types.SymbolNode('URIError.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(URIError, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint16Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint16Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint16Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint16Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint16Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint16Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint32Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint32Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint8Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint8Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint8Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint8Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint8Array.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint8Array, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint8ClampedArray.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint8ClampedArray, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint8ClampedArray.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint8ClampedArray, []));
    }),
);

interop.set(
    new types.SymbolNode('Uint8ClampedArray.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(Uint8ClampedArray, []));
    }),
);

interop.set(
    new types.SymbolNode('WeakMap.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(WeakMap, []));
    }),
);

interop.set(
    new types.SymbolNode('WeakRef.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(WeakRef, []));
    }),
);

interop.set(
    new types.SymbolNode('WeakSet.new'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Reflect.construct(WeakSet, []));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('decodeURI'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(decodeURI, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('decodeURIComponent'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(decodeURIComponent, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('encodeURI'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(encodeURI, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('encodeURIComponent'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode | types.NumberNode | types.BooleanNode>(args[0], [
            types.StringNode,
            types.NumberNode,
            types.BooleanNode,
        ]);
        const a0: string | number | boolean = args[0].value;
        return types.toAst(Reflect.apply(encodeURIComponent, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('escape'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(escape, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('eval'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(eval, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('isFinite'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(isFinite, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('isNaN'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(isNaN, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('parseFloat'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(parseFloat, undefined, [a[0]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('parseInt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(parseInt, undefined, [a[0], a[1]]));
    }),
);

// FunctionDeclaration
interop.set(
    new types.SymbolNode('unescape'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(unescape, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.concat'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.concat, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.concat'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.concat, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.flat'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: A = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: D = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.flat, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.flatMap'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: This = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.flatMap, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.isArray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Array.isArray, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.pop'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.pop, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.push'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.push, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: T = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: T = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.shift'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.shift, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.splice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.splice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.splice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: unknown = args[2].value;
        return types.toAst(Reflect.apply(Array.prototype.splice, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toSpliced'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.toSpliced, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toSpliced'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: unknown = args[2].value;
        return types.toAst(Reflect.apply(Array.prototype.toSpliced, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.unshift'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Array.prototype.unshift, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: T = args[1].value;
        return types.toAst(Reflect.apply(Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('ArrayBuffer.isView'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(ArrayBuffer.isView, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('ArrayBuffer.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(ArrayBuffer.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.adopt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(AsyncDisposableStack.prototype.adopt, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.defer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(AsyncDisposableStack.prototype.defer, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.disposeAsync'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(AsyncDisposableStack.prototype.disposeAsync, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.move'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(AsyncDisposableStack.prototype.move, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.use'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(AsyncDisposableStack.prototype.use, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack[Symbol.asyncDispose]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(AsyncDisposableStack.prototype[Symbol.asyncDispose], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.add'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.add, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.add'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.add, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.and'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.and, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.and'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.and, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.compareExchange'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        types.assertIsOneOf<types.AtomNode>(args[3], [types.AtomNode]);
        const a3: bigint = args[3].value;
        return types.toAst(Reflect.apply(Atomics.compareExchange, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.compareExchange'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Atomics.compareExchange, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.exchange'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.exchange, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.exchange'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.exchange, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.isLockFree'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Atomics.isLockFree, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.load'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Atomics.load, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.load'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Atomics.load, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.notify'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: BigInt64Array = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.notify, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.notify'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Int32Array = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.notify, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.or'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.or, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.or'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.or, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.store'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.store, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.store'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.store, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.sub'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.sub, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.sub'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.sub, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.wait'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: BigInt64Array = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Atomics.wait, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.wait'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Int32Array = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Atomics.wait, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.waitAsync'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: BigInt64Array = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Atomics.waitAsync, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.waitAsync'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Int32Array = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Atomics.waitAsync, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.xor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: bigint = args[2].value;
        return types.toAst(Reflect.apply(Atomics.xor, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Atomics.xor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Atomics.xor, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt.asIntN'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: bigint = args[1].value;
        return types.toAst(Reflect.apply(BigInt.asIntN, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt.asUintN'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: bigint = args[1].value;
        return types.toAst(Reflect.apply(BigInt.asUintN, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: BigIntToLocaleStringOptions = args[1].value;
        return types.toAst(Reflect.apply(BigInt.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(BigInt.prototype.toString, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(BigInt64Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: bigint = args[1].value;
        return types.toAst(Reflect.apply(BigInt64Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigInt64Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigInt64Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(BigUint64Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: bigint = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: bigint = args[1].value;
        return types.toAst(Reflect.apply(BigUint64Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('BigUint64Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(BigUint64Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Boolean.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Boolean.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getBigInt64'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getBigInt64, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getBigUint64'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getBigUint64, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getFloat32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getFloat32, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getFloat64'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getFloat64, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getInt16'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getInt16, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getInt32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getInt32, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getInt8'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(DataView.prototype.getInt8, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getUint16'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getUint16, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getUint32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.BooleanNode>(args[1], [types.BooleanNode]);
        const a1: boolean = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.getUint32, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.getUint8'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(DataView.prototype.getUint8, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setBigInt64'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: bigint = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setBigInt64, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setBigUint64'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: bigint = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setBigUint64, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setFloat32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setFloat32, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setFloat64'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setFloat64, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setInt16'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setInt16, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setInt32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setInt32, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setInt8'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.setInt8, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setUint16'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setUint16, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setUint32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.BooleanNode>(args[2], [types.BooleanNode]);
        const a2: boolean = args[2].value;
        return types.toAst(Reflect.apply(DataView.prototype.setUint32, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DataView.setUint8'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(DataView.prototype.setUint8, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.UTC'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 7, 7);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        types.assertIsOneOf<types.NumberNode>(args[4], [types.NumberNode]);
        const a4: number = args[4].value;
        types.assertIsOneOf<types.NumberNode>(args[5], [types.NumberNode]);
        const a5: number = args[5].value;
        types.assertIsOneOf<types.NumberNode>(args[6], [types.NumberNode]);
        const a6: number = args[6].value;
        return types.toAst(Reflect.apply(Date.UTC, undefined, [a[0], a[1], a[2], a[3], a[4], a[5], a[6]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getDate'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getDate, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getDay'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getDay, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getFullYear'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getFullYear, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getHours'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getHours, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getMilliseconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getMilliseconds, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getMinutes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getMinutes, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getMonth'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getMonth, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getSeconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getSeconds, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getTime'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getTime, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getTimezoneOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getTimezoneOffset, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCDate'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCDate, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCDay'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCDay, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCFullYear'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCFullYear, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCHours'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCHours, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCMilliseconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCMilliseconds, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCMinutes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCMinutes, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCMonth'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCMonth, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.getUTCSeconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.getUTCSeconds, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.now'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.now, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.parse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Date.parse, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setDate'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype.setDate, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setFullYear'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Date.prototype.setFullYear, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setHours'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Date.prototype.setHours, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setMilliseconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype.setMilliseconds, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setMinutes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Date.prototype.setMinutes, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setMonth'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.setMonth, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setSeconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.setSeconds, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setTime'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype.setTime, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCDate'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCDate, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCFullYear'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCFullYear, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCHours'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 4, 4);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        types.assertIsOneOf<types.NumberNode>(args[3], [types.NumberNode]);
        const a3: number = args[3].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCHours, undefined, [a[0], a[1], a[2], a[3]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCMilliseconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCMilliseconds, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCMinutes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCMinutes, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCMonth'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCMonth, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.setUTCSeconds'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.setUTCSeconds, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toDateString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toDateString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toISOString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toISOString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toJSON'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype.toJSON, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleDateString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toLocaleDateString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleDateString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.DateTimeFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.toLocaleDateString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleDateString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.DateTimeFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.toLocaleDateString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.DateTimeFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.DateTimeFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleTimeString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toLocaleTimeString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleTimeString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.DateTimeFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.toLocaleTimeString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toLocaleTimeString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.DateTimeFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Date.prototype.toLocaleTimeString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toTimeString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toTimeString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.toUTCString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.toUTCString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Date.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date[Symbol.toPrimitive]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: 'default' = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype[Symbol.toPrimitive], undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date[Symbol.toPrimitive]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: 'number' = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype[Symbol.toPrimitive], undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date[Symbol.toPrimitive]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: 'string' = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype[Symbol.toPrimitive], undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Date[Symbol.toPrimitive]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Date.prototype[Symbol.toPrimitive], undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DisposableStack.adopt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(DisposableStack.prototype.adopt, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DisposableStack.defer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(DisposableStack.prototype.defer, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DisposableStack.dispose'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(DisposableStack.prototype.dispose, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DisposableStack.move'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(DisposableStack.prototype.move, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DisposableStack.use'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(DisposableStack.prototype.use, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('DisposableStack[Symbol.dispose]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(DisposableStack.prototype[Symbol.dispose], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('FinalizationRegistry.register'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: WeakKey = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: T = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: WeakKey = args[2].value;
        return types.toAst(Reflect.apply(FinalizationRegistry.prototype.register, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('FinalizationRegistry.unregister'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: WeakKey = args[0].value;
        return types.toAst(Reflect.apply(FinalizationRegistry.prototype.unregister, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Float32Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float32Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float32Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float32Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Float64Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Float64Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Float64Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Float64Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Function.apply'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Function = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Function.prototype.apply, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Function.bind'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Function = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: unknown = args[2].value;
        return types.toAst(Reflect.apply(Function.prototype.bind, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Function.call'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Function = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: unknown = args[2].value;
        return types.toAst(Reflect.apply(Function.prototype.call, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Function.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Function.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Function[Symbol.hasInstance]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Function.prototype[Symbol.hasInstance], undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Int16Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int16Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int16Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int16Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Int32Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int32Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int32Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int32Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Int8Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Int8Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Int8Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Int8Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('JSON.parse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(JSON.parse, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('JSON.stringify'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.StringNode | types.NumberNode>(args[2], [types.StringNode, types.NumberNode]);
        const a2: string | number = args[2].value;
        return types.toAst(Reflect.apply(JSON.stringify, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('JSON.stringify'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.StringNode | types.NumberNode>(args[2], [types.StringNode, types.NumberNode]);
        const a2: string | number = args[2].value;
        return types.toAst(Reflect.apply(JSON.stringify, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Map.clear'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Map.prototype.clear, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Map.delete'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        return types.toAst(Reflect.apply(Map.prototype.delete, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Map.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Map.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Map.get'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        return types.toAst(Reflect.apply(Map.prototype.get, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Map.has'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        return types.toAst(Reflect.apply(Map.prototype.has, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Map.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: V = args[1].value;
        return types.toAst(Reflect.apply(Map.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.abs'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.abs, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.acos'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.acos, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.acosh'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.acosh, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.asin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.asin, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.asinh'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.asinh, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.atan'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.atan, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.atan2'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Math.atan2, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.atanh'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.atanh, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.cbrt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.cbrt, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.ceil'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.ceil, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.clz32'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.clz32, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.cos'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.cos, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.cosh'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.cosh, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.exp'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.exp, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.expm1'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.expm1, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.floor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.floor, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.fround'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.fround, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.hypot'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Math.hypot, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.imul'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Math.imul, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.log'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.log, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.log10'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.log10, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.log1p'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.log1p, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.log2'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.log2, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.max'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Math.max, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.min'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Math.min, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.pow'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Math.pow, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.random'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Math.random, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.round'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.round, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.sign'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.sign, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.sin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.sin, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.sinh'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.sinh, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.sqrt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.sqrt, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.tan'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.tan, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.tanh'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.tanh, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Math.trunc'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Math.trunc, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.toExponential'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Number.prototype.toExponential, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.toFixed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Number.prototype.toFixed, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Number.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Number.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.toPrecision'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Number.prototype.toPrecision, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Number.prototype.toString, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Number.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Number.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.create'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode | types.AtomNode>(args[0], [types.AtomNode, types.AtomNode]);
        const a0: object | unknown = args[0].value;
        return types.toAst(Reflect.apply(Object.create, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.create'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode | types.AtomNode>(args[0], [types.AtomNode, types.AtomNode]);
        const a0: object | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(Object.create, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.defineProperties'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(Object.defineProperties, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.defineProperty'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: PropertyKey = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: unknown = args[2].value;
        return types.toAst(Reflect.apply(Object.defineProperty, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.freeze'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Object.freeze, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.freeze'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Object.freeze, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.freeze'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Object.freeze, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.getOwnPropertyDescriptor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: PropertyKey = args[1].value;
        return types.toAst(Reflect.apply(Object.getOwnPropertyDescriptor, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.getOwnPropertyNames'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Object.getOwnPropertyNames, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.getPrototypeOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Object.getPrototypeOf, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.hasOwnProperty'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: PropertyKey = args[0].value;
        return types.toAst(Reflect.apply(Object.prototype.hasOwnProperty, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.isExtensible'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Object.isExtensible, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.isFrozen'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Object.isFrozen, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.isPrototypeOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Object = args[0].value;
        return types.toAst(Reflect.apply(Object.prototype.isPrototypeOf, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.isSealed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Object.isSealed, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: object = args[0].value;
        return types.toAst(Reflect.apply(Object.keys, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.preventExtensions'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Object.preventExtensions, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.propertyIsEnumerable'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: PropertyKey = args[0].value;
        return types.toAst(Reflect.apply(Object.prototype.propertyIsEnumerable, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.seal'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Object.seal, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Object.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Object.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Object.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Object.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.all'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Promise.all, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.finally'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode | types.NilNode>(args[0], [types.AtomNode, types.NilNode]);
        const a0: unknown | undefined = args[0].value;
        return types.toAst(Reflect.apply(Promise.prototype.finally, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.race'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Promise.race, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.reject'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: any = args[0].value;
        return types.toAst(Reflect.apply(Promise.reject, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.resolve'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Promise.resolve, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.resolve'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Promise.resolve, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Promise.resolve'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Promise.resolve, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Proxy.revocable'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: ProxyHandler = args[1].value;
        return types.toAst(Reflect.apply(Proxy.revocable, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.add'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.add, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.clear'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Set.prototype.clear, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.delete'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.delete, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.difference'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.difference, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Set.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.has'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.has, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.intersection'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.intersection, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.isDisjointFrom'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.isDisjointFrom, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.isSubsetOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.isSubsetOf, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.isSupersetOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.isSupersetOf, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.symmetricDifference'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.symmetricDifference, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Set.union'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ReadonlySetLike = args[0].value;
        return types.toAst(Reflect.apply(Set.prototype.union, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('SharedArrayBuffer.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(SharedArrayBuffer.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.anchor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.anchor, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.big'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.big, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.blink'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.blink, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.bold'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.bold, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.charAt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.charAt, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.charCodeAt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.charCodeAt, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.codePointAt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.codePointAt, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.concat'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.concat, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.endsWith'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.endsWith, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.fixed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.fixed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.fontcolor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.fontcolor, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.fontsize'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.fontsize, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.fontsize'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.fontsize, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.fromCharCode'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(String.fromCharCode, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.isWellFormed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.isWellFormed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.italics'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.italics, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.link'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.link, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.localeCompare'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.localeCompare, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.localeCompare'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.LocalesArgument = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: Intl.CollatorOptions = args[2].value;
        return types.toAst(Reflect.apply(String.prototype.localeCompare, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.localeCompare'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[1], [types.StringNode, types.AtomNode]);
        const a1: string | unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: Intl.CollatorOptions = args[2].value;
        return types.toAst(Reflect.apply(String.prototype.localeCompare, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.match'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.match, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.match'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.match, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.matchAll'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: RegExp = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.matchAll, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.normalize'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.normalize, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.normalize'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.normalize, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.padEnd'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.StringNode>(args[1], [types.StringNode]);
        const a1: string = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.padEnd, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.padStart'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.StringNode>(args[1], [types.StringNode]);
        const a1: string = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.padStart, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.repeat'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.repeat, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.replace'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.replace, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.replace'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.StringNode>(args[1], [types.StringNode]);
        const a1: string = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.replace, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.replace'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.replace, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.replace'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.StringNode>(args[1], [types.StringNode]);
        const a1: string = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.replace, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.replaceAll'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.replaceAll, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.replaceAll'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.StringNode>(args[1], [types.StringNode]);
        const a1: string = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.replaceAll, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.search'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.search, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.search'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.search, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.small'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.small, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.split'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.split, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.split'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.split, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.startsWith'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.startsWith, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.strike'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.strike, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.sub'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.sub, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.substr'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.substr, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.substring'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(String.prototype.substring, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.sup'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.sup, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toLocaleLowerCase'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.toLocaleLowerCase, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toLocaleLowerCase'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.toLocaleLowerCase, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toLocaleUpperCase'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: Intl.LocalesArgument = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.toLocaleUpperCase, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toLocaleUpperCase'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        return types.toAst(Reflect.apply(String.prototype.toLocaleUpperCase, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toLowerCase'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.toLowerCase, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toUpperCase'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.toUpperCase, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.toWellFormed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.toWellFormed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.trim'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.trim, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.trimEnd'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.trimEnd, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.trimLeft'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.trimLeft, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.trimRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.trimRight, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.trimStart'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.trimStart, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('String[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(String.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Symbol.for'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Symbol.for, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Symbol.keyFor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: symbol = args[0].value;
        return types.toAst(Reflect.apply(Symbol.keyFor, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Symbol[Symbol.toPrimitive]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Symbol.prototype[Symbol.toPrimitive], undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Uint16Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint16Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint16Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint16Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Uint32Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint32Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint32Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint32Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Uint8Array.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8Array.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8Array[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8Array.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.at'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.at, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.copyWithin'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.copyWithin, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.entries'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.entries, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.every'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.every, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.fill'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        types.assertIsOneOf<types.NumberNode>(args[2], [types.NumberNode]);
        const a2: number = args[2].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.fill, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.filter'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.filter, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.find'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.find, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.findIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.findIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.findLast'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.findLast, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.findLastIndex'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.findLastIndex, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.forEach'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.forEach, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.from, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.from'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 3, 3);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: unknown = args[1].value;
        types.assertIsOneOf<types.AtomNode>(args[2], [types.AtomNode]);
        const a2: any = args[2].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.from, undefined, [a[0], a[1], a[2]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.includes'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.includes, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.indexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.indexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.join'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.StringNode>(args[0], [types.StringNode]);
        const a0: string = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.join, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.keys'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.keys, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.lastIndexOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.lastIndexOf, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.map, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.of'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.of, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reduce, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reduce'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reduce, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reduceRight, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: U = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reduceRight'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reduceRight, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.reverse'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.reverse, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: ArrayLike = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.slice'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.slice, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.some'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: any = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.some, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.sort'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.sort, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.subarray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.subarray, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.toLocaleString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.toLocaleString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.StringNode | types.AtomNode>(args[0], [types.StringNode, types.AtomNode]);
        const a0: string | unknown = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: Intl.NumberFormatOptions = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.toLocaleString, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.toReversed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.toReversed, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.toSorted'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: unknown = args[0].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.toSorted, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.toString'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.toString, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.valueOf'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.valueOf, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.values'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.values, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.with'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.NumberNode>(args[0], [types.NumberNode]);
        const a0: number = args[0].value;
        types.assertIsOneOf<types.NumberNode>(args[1], [types.NumberNode]);
        const a1: number = args[1].value;
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype.with, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray[Symbol.iterator]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(Uint8ClampedArray.prototype[Symbol.iterator], undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakMap.delete'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        return types.toAst(Reflect.apply(WeakMap.prototype.delete, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakMap.get'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        return types.toAst(Reflect.apply(WeakMap.prototype.get, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakMap.has'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        return types.toAst(Reflect.apply(WeakMap.prototype.has, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakMap.set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 2, 2);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: K = args[0].value;
        types.assertIsOneOf<types.AtomNode>(args[1], [types.AtomNode]);
        const a1: V = args[1].value;
        return types.toAst(Reflect.apply(WeakMap.prototype.set, undefined, [a[0], a[1]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakRef.deref'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 0, 0);
        return types.toAst(Reflect.apply(WeakRef.prototype.deref, undefined, []));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakSet.add'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(WeakSet.prototype.add, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakSet.delete'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(WeakSet.prototype.delete, undefined, [a[0]]));
    }),
);

// MethodSignature
interop.set(
    new types.SymbolNode('WeakSet.has'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        types.assertVariableArgumentCount(args.length, 1, 1);
        types.assertIsOneOf<types.AtomNode>(args[0], [types.AtomNode]);
        const a0: T = args[0].value;
        return types.toAst(Reflect.apply(WeakSet.prototype.has, undefined, [a[0]]));
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AggregateError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AggregateError);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AggregateError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AggregateError);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AggregateError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AggregateError);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AggregateError.errors'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AggregateError.prototype.errors);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AggregateError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AggregateError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('ArrayBuffer.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ArrayBuffer.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('ArrayBuffer.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ArrayBuffer.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.disposed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AsyncDisposableStack.prototype.disposed);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('AsyncDisposableStack.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AsyncDisposableStack.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigInt.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigInt64Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt64Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigInt64Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt64Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigInt64Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt64Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigInt64Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt64Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigInt64Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt64Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigUint64Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigUint64Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigUint64Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigUint64Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigUint64Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigUint64Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigUint64Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigUint64Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('BigUint64Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigUint64Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Boolean.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Boolean.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('DataView.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DataView.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('DataView.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DataView.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('DataView.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DataView.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('DataView.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DataView.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Date.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Date.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('DisposableStack.disposed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DisposableStack.prototype.disposed);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('DisposableStack.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DisposableStack.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Error.cause'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Error.prototype.cause);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Error.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Error.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Error.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Error.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Error.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Error.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Error.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Error.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('EvalError.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(EvalError.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('EvalError.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(EvalError.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('EvalError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(EvalError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('EvalError.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(EvalError.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('FinalizationRegistry.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(FinalizationRegistry.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float32Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float32Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float32Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float32Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float32Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float32Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float32Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float32Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float32Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float32Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float64Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float64Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float64Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float64Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float64Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float64Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float64Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float64Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Float64Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float64Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Function.arguments'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function.prototype.arguments);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Function.caller'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function.prototype.caller);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Function.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Function.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Function.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Function.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function.prototype.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int16Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int16Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int16Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int16Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int16Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int16Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int16Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int16Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int16Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int16Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int32Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int32Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int32Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int32Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int32Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int32Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int32Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int32Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int32Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int32Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int8Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int8Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int8Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int8Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int8Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int8Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int8Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int8Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Int8Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int8Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Map.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Map.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Map.size'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Map.prototype.size);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.E'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.E);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.LN10'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.LN10);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.LN2'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.LN2);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.LOG10E'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.LOG10E);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.LOG2E'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.LOG2E);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.PI'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.PI);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Math.SQRT2'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math.SQRT2);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Number.MIN_VALUE'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Number.MIN_VALUE);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Number.NaN'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Number.NaN);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Number.POSITIVE_INFINITY'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Number.POSITIVE_INFINITY);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Number.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Number.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Object.constructor'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Object.prototype.constructor);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Object.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Object.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Promise.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Promise.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('RangeError.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(RangeError.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('RangeError.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(RangeError.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('RangeError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(RangeError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('RangeError.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(RangeError.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('ReferenceError.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ReferenceError.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('ReferenceError.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ReferenceError.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('ReferenceError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ReferenceError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('ReferenceError.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ReferenceError.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Set.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Set.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Set.size'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Set.prototype.size);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SharedArrayBuffer.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SharedArrayBuffer.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SharedArrayBuffer.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SharedArrayBuffer.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SharedArrayBuffer[Symbol.toStringTag]'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SharedArrayBuffer.prototype[Symbol.toStringTag]);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('String.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(String.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('String.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(String.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SuppressedError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SuppressedError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SuppressedError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SuppressedError.error'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError.prototype.error);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SuppressedError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SuppressedError.suppressed'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError.prototype.suppressed);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Symbol.description'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Symbol.prototype.description);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Symbol.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Symbol.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SyntaxError.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SyntaxError.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SyntaxError.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SyntaxError.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SyntaxError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SyntaxError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('SyntaxError.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SyntaxError.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('TypeError.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(TypeError.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('TypeError.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(TypeError.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('TypeError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(TypeError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('TypeError.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(TypeError.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('URIError.message'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(URIError.prototype.message);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('URIError.name'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(URIError.prototype.name);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('URIError.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(URIError.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('URIError.stack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(URIError.prototype.stack);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint16Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint16Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint16Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint16Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint16Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint16Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint16Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint16Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint16Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint16Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint32Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint32Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint32Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint32Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint32Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint32Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint32Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint32Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint32Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint32Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8Array.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8Array.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8Array.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8Array.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8Array.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8Array.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8Array.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8Array.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8Array.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8Array.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.buffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8ClampedArray.prototype.buffer);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.byteLength'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8ClampedArray.prototype.byteLength);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.byteOffset'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8ClampedArray.prototype.byteOffset);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.length'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8ClampedArray.prototype.length);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('Uint8ClampedArray.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8ClampedArray.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('WeakMap.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(WeakMap.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('WeakRef.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(WeakRef.prototype);
    }),
);

// PropertySignature
interop.set(
    new types.SymbolNode('WeakSet.prototype'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(WeakSet.prototype);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('AggregateError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AggregateError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('ArrayBuffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ArrayBuffer);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('AsyncDisposableStack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(AsyncDisposableStack);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Atomics'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Atomics);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('BigInt'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('BigInt64Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigInt64Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('BigUint64Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(BigUint64Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Boolean'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Boolean);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('DataView'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DataView);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Date'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Date);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('DisposableStack'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(DisposableStack);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Error'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Error);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('EvalError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(EvalError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('FinalizationRegistry'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(FinalizationRegistry);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Float32Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float32Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Float64Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Float64Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Function'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Function);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Infinity'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Infinity);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Int16Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int16Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Int32Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int32Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Int8Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Int8Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('JSON'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(JSON);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Map'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Map);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Math'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Math);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('NaN'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(NaN);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Number'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Number);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Object'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Object);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Promise'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Promise);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Proxy'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Proxy);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('RangeError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(RangeError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('ReferenceError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(ReferenceError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('RegExp'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(RegExp);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Set'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Set);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('SharedArrayBuffer'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SharedArrayBuffer);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('String'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(String);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('SuppressedError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SuppressedError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Symbol'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Symbol);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('SyntaxError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(SyntaxError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('TypeError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(TypeError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('URIError'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(URIError);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Uint16Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint16Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Uint32Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint32Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Uint8Array'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8Array);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('Uint8ClampedArray'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(Uint8ClampedArray);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('WeakMap'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(WeakMap);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('WeakRef'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(WeakRef);
    }),
);

// VariableDeclaration
interop.set(
    new types.SymbolNode('WeakSet'),
    new types.FunctionNode((...args: types.AstNode[]): types.AstNode => {
        return types.toAst(WeakSet);
    }),
);
