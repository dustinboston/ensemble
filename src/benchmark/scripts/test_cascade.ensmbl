// Iteration on evaluations interpreted as boolean values.

<load-file      "../lib/load-file-once.ensmbl">
<load-file-once "../lib/trivial.ensmbl">   // gensym

// (or x1 x2 .. xn x)
// is almost rewritten as
// (if x1 x1 (if x2 x2 (.. (if xn xn x))))
// except that each argument is evaluated at most once.
// Without arguments, returns nil.
<defmacro! or <function <& xs>
  <if <lt <count xs> 2>
    <first xs>
    <const [r <gensym>]
      <quasiquote
        <const [<unquote r> <unquote <first xs>>]
          <if <unquote r> <unquote r> <or <splice-unquote <rest xs>>>>
        >
      >
    >
  >
>>

// Conjunction of predicate values (pred x1) and .. and (pred xn)
// Evaluate pred x for each x in turn. Return false if a result
// is nil or false, without evaluating the predicate for the
// remaining elements.  If all test pass, return true.
<var every?
  <function <pred xs>
    // pred   : Element -> interpreted as a logical value
    // xs     : sequence of Elements x1 x2 .. xn
    // return : boolean
    <cond 
      <empty? xs>       true
      <pred <first xs>> <every? pred <rest xs>>
      true              false
    >
  >
>

// Disjunction of predicate values (pred x1) or .. (pred xn)
// Evaluate (pred x) for each x in turn. Return the first result
// that is neither nil nor false, without evaluating the predicate
// for the remaining elements.  If all tests fail, return nil.
<var some
  <function <pred xs>
    // pred   : Element -> interpreted as a logical value
    // xs     : sequence of Elements x1 x2 .. xn
    // return : boolean
    <if <empty? xs>
      nil
      <or <pred <first xs>>
          <some pred <rest xs>>
      >
    >
  >
>

// Search for first evaluation returning nil or false.
// Without arguments, returns true.
<defmacro! and
  <function <& xs>
    // Arguments and the result are interpreted as boolean values.
    <cond 
      <empty? xs>      true
      <eq 1 <count xs>> <first xs>
      true             <const [condvar <gensym>]
                         <quasiquote
                           <const [<unquote condvar> <unquote <first xs>>]
                             <if <unquote condvar> <and <splice-unquote <rest xs>>> <unquote condvar>>
                           >
                         >
                       >
    >
  >
>