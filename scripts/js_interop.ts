/**
 * This file contains functions to generate interop code for a collection of built-in JavaScript functions.
 * The generated interop code allows JavaScript functions to be called from the Ensemble runtime environment.
 *
 * @todo see TODO below, Figure out how to apply the context to the function and the rest of the arguments properly. This isn't working.
 * @file
 */

import { BuiltinCollection, BuiltinDefinition, DefinitionType, javascriptDefinitions, NamedParameter, ParameterType } from '../data/javascript_definitions.ts';
import { reservedWords } from '../data/reserved_words.ts';

const ARGS_NAME = 'astArgs';

/**
 * Builds interop code for a given collection of built-in functions.
 * @param collection - A collection of built-in functions, where the key is the function name and the value is
 * either a single function definition or an array of function definitions.
 * @returns An array of strings representing the generated interop code.
 */
function buildInterop(collection: BuiltinCollection) {
  const lines: string[] = [
    '/**',
    ' * @file',
    ' *',
    ' * __WARNING: DO NOT MODIFY THIS FILE.__ This file was generated by `scripts/js_interop.ts` and should not be modified directly.',
    ' * To update the file, modify `data/javascript_definitions.ts` and run `deno task generate-interop` and `deno fmt`.',
    ' *',
    ' * This file contains interop functions for ALL built-in JavaScript functions and properties. ',
    ' * It works by converting Ensemble AST Nodes into JavaScript values that are use to execute or return a JavaScript method or property.',
    ' * It also provides runtime type checking, validation, and error handling.',
    ' *',
    ' * In theory the `javascript_definitions.ts` file could be analyzed directly by Ensemble at runtime. However, it is very helpful to pre-generate ',
    ' * the interop code so that we can visually and programmatically inspect it to find and fix errors at compile time.',
    ' */',
    "import * as types from '../js/types.ts';",
    'export const javascriptNamespace = new Map<types.MapKeyNode, types.FunctionNode>();',
  ];

  for (const entry of Object.entries(collection)) {
    const builtinName = entry[0];
    const builtinDefinition = entry[1];

    if (Array.isArray(builtinDefinition)) {
      const bodies: string[] = [];
      for (const def of builtinDefinition) {
        bodies.push(buildFunctionBody(builtinName, def));
      }
      const body = bodies.join('\n');
      lines.push(getTemplate(builtinName, body));
    } else {
      const body = buildFunctionBody(builtinName, builtinDefinition);
      lines.push(getTemplate(builtinName, body));
    }
  }

  return lines;
}

/**
 * Generates a template string for setting a symbol in a namespace with a function node.
 * @param symbolName - The name of the symbol to be set in the namespace.
 * @param body - The body of the function to be executed.
 * @returns A template string that sets the symbol in the namespace with the provided function body.
 */
function getTemplate(symbolName: string, body: string) {
  return `
    javascriptNamespace.set(
      new types.SymbolNode('${symbolName}'),
      new types.FunctionNode((...${ARGS_NAME}: types.AstNode[]): types.AstNode => {
        try {
          ${body}
          return types.createErrorNode(types.createStringNode('Invalid arguments to "${symbolName}"'));
        } catch (e) {
          if (types.isErrorNode(e)) return e;
          if (types.isAstNode(e)) return types.createErrorNode(e);
          if (e instanceof Error) return types.createErrorNode(types.createStringNode(e.message));
          return types.createErrorNode(types.createStringNode(String(e)));
        }
      })
    );  
  `;
}

/**
 * Builds an interop function based on the provided builtin definition.
 *
 * @param builtinName - The name of the builtin function or property.
 * @param builtinDefinition - The definition of the builtin, including its type and parameters.
 * @returns A string representing the generated interop function.
 * @throws {Error} If the parameters are not an array.
 * @throws {TypeError} If the definition type is unknown.
 */
function buildFunctionBody(builtinName: string, builtinDefinition: BuiltinDefinition) {
  const { /* type, returnValue, */ parameters } = builtinDefinition;
  if (!Array.isArray(parameters)) {
    throw new Error(`no parameters ${JSON.stringify(builtinDefinition)}`);
  }

  const symbolName = builtinName.replace('.prototype', '');
  const isPrototype = builtinName.includes('.prototype') && !builtinName.endsWith('.prototype');

  if (isPrototype) {
    parameters.unshift(['context', ParameterType.This]);
  }

  const { required, total } = countParameters(parameters);
  const restParameter = getRestParameter(parameters);
  const argumentCountAssertion = getArgumentCountAssertion(required, total, restParameter);
  const parameterValidation = parameters.map((parameter, index) => getParameterTypeAssertions(parameter, index));
  const parameterTypeValidations = parameterValidation.map(({ typeValues }) => typeValues);
  const { variableNames, variableAssignments } = getBindings(parameters, builtinName, builtinDefinition.baseClass, parameterTypeValidations);

  const argumentAssertions = parameterValidation.map(({ assertions }) => assertions).join(' && ');
  const andArgumentAssertions = argumentAssertions ? ` && ${argumentAssertions}` : '';

  const body = [];
  // if (builtinDefinition.validations) body.push(...builtinDefinition.validations);
  body.push(`if (${argumentCountAssertion}${andArgumentAssertions}) {`);
  if (variableAssignments.length > 0) body.push(...variableAssignments);

  if (builtinDefinition.type === DefinitionType.InstanceMethod || builtinDefinition.type === DefinitionType.StaticMethod) {
    body.push(getMethodResult(builtinName, variableNames));
  }

  if (builtinDefinition.type === DefinitionType.InstanceProperty || builtinDefinition.type === DefinitionType.StaticProperty) {
    body.push(getPropertyResult(builtinName));
  }

  if (builtinDefinition.type === DefinitionType.Constructor) {
    body.push(getConstructorResult(symbolName, variableNames, builtinName));
  }

  // if (body === '') {
  //   throw new TypeError(`Unknown definition type: ${builtinDefinition.type}`);
  // }

  body.push(`return types.toAst(result);`, '}');
  return body.join('\n');
}

/**
 * Generates a TypeScript function string that creates an interop function for a given constructor or function.
 *
 * @param symbolName - The name of the symbol representing the constructor or function.
 * @param variableNames - An array of variable names to be used as arguments in the constructor or function.
 * @param builtinName - The name of the built-in constructor or function to be called.
 * @param argumentCountAssertion - A string containing the assertion code for the argument count.
 * @param variableAssignments - An array of strings containing the variable assignment code.
 * @returns A string representing the TypeScript function that sets up the interop function.
 */
function getConstructorResult(symbolName: string, variableNames: string[], builtinName: string) {
  // Handle Deno lint error: Array Constructor is not allowed when constructing a new Array without any arguments.
  // = hint: Use array literal notation (e.g. []) or single argument specifying array size only (e.g. new Array(5)
  if ((symbolName === 'Array' || symbolName === 'Array.new') && variableNames.length === 0) {
    return 'const result: unknown[] = [];';
  } else {
    if (symbolName.endsWith('.new')) {
      return `const result = new ${builtinName.replace('.new', '')}(${variableNames.join(', ')}); // new`;
    } else {
      return `const result = ${builtinName}(${variableNames.join(', ')}); // ctor`;
    }
  }
}

/**
 * Generates a string representation of a function that sets a property in a namespace.
 * @param builtinName - The name of the built-in function to be called.
 * @returns A string containing the code to set the property in the namespace.
 */
function getPropertyResult(builtinName: string) {
  return `const result = ${builtinName};`;
}

/**
 * Generates a string representation of a function that sets a method interop function in a namespace.
 *
 * @param builtinName - The name of the built-in function, which may include a context (e.g., "Math.max").
 * @param variableNames - An array of variable names to be used as arguments in the function call.
 * @param argumentCountAssertion - A string containing code to assert the number of arguments.
 * @param variableAssignments - An array of strings containing code for variable assignments.
 * @returns A string representing the function that sets the method interop function in the namespace.
 */
function getMethodResult(builtinName: string, variableNames: string[]) {
  const nameParts = builtinName.split('.');
  const context = nameParts.length > 1 ? nameParts.slice(0, -1).join('.') : nameParts[0];

  const isPrototype = builtinName.includes('.prototype') && !builtinName.endsWith('.prototype');

  if (builtinName.endsWith('.call')) {
    return `const result = Function.prototype.call.apply(${context}, [${variableNames.join(', ')}]);`;
  } else if (isPrototype) {
    // TODO: Figure out how to apply the context to the function and the rest of the arguments properly. This isn't working.
    return `const result = ${builtinName}.call(${variableNames.join(', ')});`;
  } else {
    return `const result = ${builtinName}(${variableNames.join(', ')});`;
  }
}

/**
 * Generates variable names and assignments for a given set of parameters.
 *
 * @param parameters - An array of tuples where each tuple contains a parameter name and its type.
 * @returns An object containing two arrays:
 *  - `variableNames`: An array of sanitized variable names, prefixed with '...' if they are rest parameters.
 *  - `variableAssignments`: An array of strings representing the variable assignments, converting the arguments to JavaScript values.
 *
 * @throws {TypeError} If a parameter tuple is malformed, i.e., it does not contain both a name and a type.
 */
function getBindings(parameters: BuiltinDefinition['parameters'], builtinName: string, baseClass?: string, parameterTypeValidations?: string[]) {
  const variableNames: string[] = [];
  const variableAssignments: string[] = [];

  let contextDecrement = 0;
  if (parameters.length && parameters[0][0] === 'context' && parameters[0][1] === ParameterType.This) {
    contextDecrement += 1;
  }

  for (let i = 0; i < parameters.length; i++) {
    const [name, type] = parameters[i];
    if (name === undefined || type === undefined) {
      throw new TypeError(`Named parameter at position ${i} is malformed. Expected a tuple of '[name, type]' but got '${parameters[0]}'`);
    }

    const restPrefix = isRestParameter(name) ? '...' : '';
    const optionalSuffix = isParameterOptional(name) ? ' ?? new types.NilNode()' : '';

    const variableName = sanitizeName(name);
    variableNames.push(restPrefix + variableName);

    const typeValidation = parameterTypeValidations ? parameterTypeValidations[i - contextDecrement] : '';

    if (name === 'context' && type === ParameterType.This) {
      // const base = baseClass ? `${baseClass}` : builtinName.replace('.prototype', '').replace(/(\[\w*\.\w*\]|\.\w*)$/, '');
      variableAssignments.push(`/* context */
        const ${variableName} = types.toJs<${typeValidation}>(${ARGS_NAME}[${i}]);`);
      continue;
    }
    variableAssignments.push(
      isRestParameter(name)
        ? `/* rest */
        const ${variableName} = ${ARGS_NAME}.slice(${i}).map(x => types.toJs<${typeValidation}>(x${optionalSuffix}));`
        : `/* not rest */ 
        const ${variableName} = types.toJs<${typeValidation}>(${ARGS_NAME}[${i}]${optionalSuffix});`,
    );
  }
  return { variableNames, variableAssignments };
}

/**
 * Generates an assertion string for the number of arguments passed to a function.
 *
 * @param required - The number of required arguments.
 * @param total - The total number of arguments.
 * @param restParameter - An optional named parameter representing the rest parameter.
 * @returns A string containing the appropriate assertion for the argument count.
 */
function getArgumentCountAssertion(required: number, total: number, restParameter: NamedParameter | undefined) {
  if (required === total) {
    // return `types.assertArgumentCount(${ARGS_NAME}.length, ${total});`;
    return `(${ARGS_NAME}.length === ${total})`;
  } else if (restParameter) {
    // return `types.assertMinimumArgumentCount(${ARGS_NAME}.length, ${required}});`;
    return `(${ARGS_NAME}.length >= ${required}})`;
  } else {
    // return `types.assertVariableArgumentCount(${ARGS_NAME}.length, ${required}, ${total});`;
    return `(${ARGS_NAME}.length >= ${required} && ${ARGS_NAME}.length <= ${total})`;
  }
}

/**
 * Counts the total, optional, and required parameters from a list of named parameters.
 *
 * @param parameters - An array of named parameters.
 * @returns An object containing the count of optional, required, and total parameters.
 */
function getRestParameter(parameters: NamedParameter[]) {
  const restParameter = parameters.find((p) => p[0].startsWith('...'));
  return restParameter;
}

/**
 * Sanitizes a given name by removing specific characters and replacing reserved words.
 *
 * This function performs the following transformations:
 * - Removes occurrences of '...' and '?' from the input name.
 * - Replaces the name 'this' with 'self' to avoid reserved word conflicts.
 *
 * @param name - The name to be sanitized.
 * @returns The sanitized name.
 */
function sanitizeName(name: string) {
  const baseName = name.replace('...', '').replace('?', '');
  if (reservedWords.has(baseName)) {
    return `${baseName}Value`;
  }
  return baseName;
}

/**
 * Checks if the given parameter name is a rest parameter.
 *
 * A rest parameter in TypeScript is denoted by three consecutive dots (`...`)
 * at the beginning of the parameter name.
 *
 * @param name - The name of the parameter to check.
 * @returns `true` if the parameter name starts with `...`, otherwise `false`.
 */
function isRestParameter(name: string) {
  return name.startsWith('...');
}

/**
 * Checks if a parameter name indicates that it is optional.
 *
 * @param name - The name of the parameter to check.
 * @returns `true` if the parameter name ends with a question mark (`?`), indicating it is optional; otherwise, `false`.
 */
function isParameterOptional(name: string) {
  return name.endsWith('?');
}

/**
 * Counts the number of required and total parameters in a given array of NamedParameter objects.
 *
 * @param parameters - An array of NamedParameter objects to be analyzed.
 * @returns An object containing the count of required parameters and the total number of parameters.
 */
function countParameters(parameters: NamedParameter[]) {
  const required = parameters.filter((p) => !isParameterOptional(p[0])).length;
  return { required, total: parameters.length };
}

/**
 * Logs the details of a built-in function definition to the console.
 *
 * @param builtinName - The name of the built-in function.
 * @param builtinDefinition - An object containing the definition of the built-in function.
 */
function _logBuiltinDefinition(builtinName: string, builtinDefinition: BuiltinDefinition) {
  console.log([
    `Name: ${builtinName}`,
    `Type: ${builtinDefinition.type}`,
    `Params: ${JSON.stringify(builtinDefinition.parameters)}`,
    `Return: ${JSON.stringify(builtinDefinition.returnValue)}`,
    `Inherit: ${JSON.stringify(builtinDefinition.inheritedFrom)}`,
    '// -----------------------------------',
  ].join('\n'));
}

/**
 * Generates type assertions for a given parameter based on its type.
 *
 * The function handles various parameter types and generates appropriate type assertions
 * using the `types` module. The assertions ensure that the arguments passed to a function
 * match the expected types. The function supports a wide range of parameter types, including:
 *
 * - AST nodes
 * - Atom nodes
 * - Boolean nodes
 * - Error nodes
 * - Function nodes
 * - Map nodes
 * - Nil nodes
 * - Number nodes
 * - Promise nodes
 * - String nodes
 * - Symbol nodes
 * - Vector nodes
 * - Unions of the above types
 *
 * @param parameter - A tuple containing the parameter name and its type.
 * @param index - The index of the parameter in the argument list.
 * @returns A string containing the type assertions for the parameter.
 */
function getParameterTypeAssertions(parameter: NamedParameter, index: number) {
  const [parameterName, parameterType] = parameter;

  const assertions = [];
  const typeValues: string[] = [];
  switch (parameterType) {
    // AST NODE
    // --------

    // any
    case ParameterType.OptionalAny:
    // T
    case ParameterType.OptionalT:
    // this
    case ParameterType.OptThis:
    // unknown
    case ParameterType.OptionalUnknown:
    // object
    case ParameterType.Object:
    // T
    case ParameterType.T:
    // this
    case ParameterType.This:
    // U
    case ParameterType.U:
    // any
    case ParameterType.Any: {
      assertions.push(`types.isAstNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.AstNode');
      break;
    }

    // ATOM NODE
    // ---------
    // e.g. Atom<Intl.Locale>
    // TODO: Update Atom to take any native JS object

    // WeakKey
    case ParameterType.OptionalWeakKey:
    // WeakKey
    case ParameterType.WeakKey:
    // Function
    case ParameterType.FunctionBuiltin:
    // WeakMap<K, V>
    case ParameterType.WeakMap:
    // (new (...args: A) => R) - A constructor function to invoke, e.g. Atom<AggregateError> */
    case ParameterType.OptionalConstructTargetFunction:
    case ParameterType.ConstructTargetFunction:
    case ParameterType.ConstructorFunction:
    // Intl.Locale
    case ParameterType.Locale:
    // Intl.NumberFormat
    case ParameterType.NumberFormat:
    // Intl.PluralRule
    case ParameterType.PluralRules:
    // Intl.RelativeTimeFormat
    case ParameterType.RelativeTimeFormat:
    // Intl.Segmenter
    case ParameterType.Segmenter:
    // RegExp
    case ParameterType.RegExp:
    // SharedArrayBuffer
    case ParameterType.SharedArrayBuffer:
    // WeakRef<T>
    case ParameterType.WeakRefT:
    // WeakSet<T>
    case ParameterType.WeakSet:
    // Intl.ListFormat
    case ParameterType.ListFormat:
    // Intl.DisplayNames
    case ParameterType.DisplayNames:
    // Intl.DateTimeFormat
    case ParameterType.DateTimeFormat:
    // DataView
    case ParameterType.DataView:
    // Intl.Collator
    case ParameterType.Collator: {
      assertions.push(`types.isAtomNode(${ARGS_NAME}[${index}])`);
      typeValues.push(`types.AtomNode`);
      break;
    }

    // BOOLEAN NODE
    // ------------

    // Boolean
    case ParameterType.Boolean:
    // boolean
    case ParameterType.OptionalBoolean: {
      assertions.push(`types.isBooleanNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.BooleanNode');
      break;
    }

    // ERROR NODE
    // ----------

    // RangeError
    case ParameterType.RangeError:
    // ReferenceError
    case ParameterType.ReferenceError:
    // SyntaxError
    case ParameterType.SyntaxError:
    // TypeError
    case ParameterType.TypeError:
    // URIError
    case ParameterType.URIError:
    // Error
    case ParameterType.Error:
    // EvalError
    case ParameterType.EvalError:
    // AggregateError
    case ParameterType.AggregateError: {
      assertions.push(`types.isErrorNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.ErrorNode');
      break;
    }

    // FUNCTION NODE
    // -------------
    // Wraps a native function

    // ((key: string, value: any) => any)
    case ParameterType.ReviverFunction:
    // (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void
    case ParameterType.PromiseExecutorFunction:
    // (a: T, b: T) => number
    case ParameterType.NumericCompareFunction:
    // (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) =>
    case ParameterType.NumericReduceCallbackFunction:
    // (substring: string, ...args: any[]) => string
    case ParameterType.ReplacerFunction:
    // (v: T, k: number) => number
    case ParameterType.NumericFromMapFunction:
    // (value: V, key: K, map: ReadonlyMap<K, V>) => void
    case ParameterType.MapForEachCallbackFunction:
    // (value: T, index: number, array: T[]) => unknown
    case ParameterType.PredicateFunction:
    // (value: T) => TResult | PromiseLike<TResult1>
    case ParameterType.PromiseFulfilledCallback:
    // (value: T, index: number, array: T[]) => void
    case ParameterType.NumericForEachCallbackFunction:
    // (value: T, index: number, array: T[]) => unknown
    case ParameterType.NumericPredicateFunction:
    // (value: T, value2: T, set: Set<T>) => void
    case ParameterType.SetForEachCallback:
    // groupBy<K extends PropertyKey, T>( items: Iterable<T>, keySelector: (item: T, index: number) => K): Partial<Record<K, T[]>>;
    case ParameterType.KeySelectorFunction:
    // (v: T) => U
    case ParameterType.FunctionAwaitedTU:
    // (v: T, k: number) => U
    case ParameterType.FunctionTNumberU:
    // Function
    case ParameterType.Function:
    // (value: T, index: number, array: T[]) => void
    case ParameterType.ForEachCallbackFunction:
    // (heldValue: T) => void
    case ParameterType.CleanupCallback:
    // (a: T, b: T) => number
    case ParameterType.CompareFunction:
    case ParameterType.ApplyTargetFunction:
    // (T, number, T[]) => U
    case ParameterType.ArrayMapCallbackFunction: {
      // TODO: Assert function types
      assertions.push(`types.isFunctionNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.FunctionNode');
      break;
    }

    // (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T
    case ParameterType.GenericReduceCallbackFunction: {
      assertions.push(`(types.isFunctionNode(${ARGS_NAME}[${index}]))`);
      break;
    }

    // MAP NODE
    // --------

    // 	interface NumberFormatOptions { numberingSystem?: string | undefined; compactDisplay?: 'short' | 'long' | undefined; ... }
    case ParameterType.OptionalNumberFormatOptions:
    // interface PropertyDescriptor { configurable?: boolean; value?: any; writable?: boolean; get?(): any; ... }
    case ParameterType.PropertyDescriptor:
    // '{ async: false, value: 'not-equal' }
    case ParameterType.ObjBoolStr:
    // Record<string, boolean>
    case ParameterType.RecStrBool:
    // { [string]: number | number[] }
    case ParameterType.WeekInfo:
    // interface ResolvedCollatorOptions { usage: string; numeric: boolean; ... }
    case ParameterType.ResolvedCollatorOptions:
    // interface ResolvedNumberFormatOptions { locale: string; ... }
    case ParameterType.ResolvedNumberFormatOptions:
    // 	interface SegmenterOptions { localeMatcher?: 'best fit' | undefined; ... }
    case ParameterType.SegmenterOptions:
    // 	interface PluralRulesOptions { localeMatcher?: 'lookup' | 'best fit' | undefined; minimumIntegerDigits?: number | undefined; ... }
    case ParameterType.PluralRulesOptions:
    // interface ResolvedPluralRulesOptions { locale: string; type: string; }
    case ParameterType.ResolvedPluralRulesOptions:
    // 	interface ListFormatOptions { localeMatcher?: ListFormatLocaleMatcher | undefined; ... }; type ListFormatLocaleMatcher = 'lookup' | 'best fit';
    case ParameterType.ListFormatOptions:
    // 	interface LocaleOptions { baseName?: string; numeric?: boolean; ... }
    case ParameterType.LocaleOptions:
    // interface RelativeTimeFormatOptions { localeMatcher?: RelativeTimeFormatLocaleMatcher; ... }
    case ParameterType.RelativeTimeFormatOptions:
    // { [string]: string }
    case ParameterType.TextInfo:
    // interface ResolvedDateTimeFormatOptions { locale: string; hour12: boolean; ... }
    case ParameterType.ResolvedDateTimeFormatOptions:
    // interface ResolvedDisplayNamesOptions { locale: string; ... }
    case ParameterType.ResolvedDisplayNamesOptions:
    // interface ResolvedListFormatOptions { locale: string; ... }
    case ParameterType.ResolvedListFormatOptions:
    // interface ResolvedRelativeTimeFormatOptions { locale: string; ... }
    case ParameterType.ResolvedRelativeTimeFormatOptions:
    // 'interface ResolvedSegmenterOptions { locale: string; ... }
    case ParameterType.ResolvedSegmenterOptions:
    // interface TemplateStringsArray extends ReadonlyArray<string> { readonly raw: readonly string[]; }
    case ParameterType.TemplateStringsArray:
    // interface NumberFormatOptions { localeMatcher?: 'lookup' | 'best fit' | undefined; minimumIntegerDigits?: number | undefined; ...}
    case ParameterType.NumberFormatOptions:
    // interface RegExpExecArray { groups?: { [key: string]: string; } }
    case ParameterType.RegExpExecArray:
    // interface RegExpMatchArray { groups?: {[key: string]: string; } }
    case ParameterType.RegExpMatchArray:
    // { [s: string]: T }
    case ParameterType.PlainObject:
    // interface PropertyDescriptor { configurable?: boolean; value?: any; get?(): any; ... }
    case ParameterType.PropertyDescriptorMap:
    // Map
    case ParameterType.Map:
    // Map<any, any>
    case ParameterType.UntypedMap:
    // { proxy: T; revoke: () => void }
    case ParameterType.DisplayNamesOptions:
    // interface DateTimeFormatOptions { localeMatcher?: 'best fit' | 'lookup' | undefined; ... }
    case ParameterType.DateTimeFormatOptions:
    // interface CollatorOptions { usage?: string | undefined; boolean | undefined; ... }
    case ParameterType.CollatorOptions: {
      // TODO: Assert key/value pair types
      assertions.push(`types.isMapNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.MapNode');
      break;
    }

    // NIL NODE
    // --------

    // null
    case ParameterType.Null:
    // undefined
    case ParameterType.Undef:
    // void
    case ParameterType.Void: {
      assertions.push(`types.asserNilNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.NilNode');
      break;
    }

    // NUMBER NODE
    // -----------

    // number
    case ParameterType.OptionalNumber:
    // number = 1
    case ParameterType.OptionalNumberWithInitializer1:
    // NaN
    case ParameterType.NaN:
    // number
    case ParameterType.Number:
    // Date (TODO: decide if number is sufficient for date)
    case ParameterType.Date:
    // Date | number
    case ParameterType.DateOrNumber:
    // Date | number | bigint - TODO: Update NumberNode to handle dates and bigint internally
    case ParameterType.DateOrNumberOrBigInt:
    // BigInt
    case ParameterType.BigInt: {
      assertions.push(`types.isNumberNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.NumberNode');
      break;
    }

    // PROMISE
    // -------
    // TODO: Handle promises (for now, treat promises as T)

    // Promise<Awaited<T>>
    case ParameterType.PromiseAwaitedT:
    // Promise<T>
    case ParameterType.PromiseT: {
      assertions.push(`types.isAstNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.AstNode');
      break;
    }

    // Promise<T[]>
    case ParameterType.PromiseTArray:
    // Promise<Awaited<U>[]>
    case ParameterType.PromiseAwaitedUArray: {
      assertions.push(`types.isVectorNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.VectorNode');
      break;
    }

    // STRING NODE
    // -----------

    // string
    case ParameterType.OptionalString:
    // RegExp - TODO: determine if RegExp should be an Atom
    case ParameterType.RegExpString:
    // string | RegExp
    case ParameterType.StringOrRegExp:
    // string
    case ParameterType.String: {
      assertions.push(`types.isStringNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.StringNode');
      break;
    }

    // SYMBOL NODE
    // -----------

    // Symbol
    case ParameterType.Symbol:
    // symbol
    case ParameterType.Sym: {
      assertions.push(`types.isSymbolNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.SymbolNode');
      break;
    }

    // VECTOR NODE <AST NODE>
    // ----------------------

    // T[]
    case ParameterType.TArray:
    // Set<T>
    case ParameterType.SetT:
    // this[]
    case ParameterType.ThisTArray:
    // object[]
    case ParameterType.ObjectArray:
    // U[]
    case ParameterType.UArray:
    // (T|number)[]
    case ParameterType.TNumArr:
    //  AsyncIterable<T> | Iterable<T | PromiseLike<T>> | ArrayLike<T | PromiseLike<T>>
    case ParameterType.IterableOrArrayLike:
    // Iterable<T>
    case ParameterType.IterableT:
    // Iterable<T> | null
    case ParameterType.IterableTOrNull:
    // Iterable<T> | PromiseLike<T>
    case ParameterType.IterableTOrPromiseLikeT:
    // IterableIterator<V>
    case ParameterType.IterableIteratorV:
    // IterableIterator<T>
    case ParameterType.IterableIteratorT:
    // Iterable<readonly any[]>
    case ParameterType.IterableAny:
    // IterableIterator<K>
    case ParameterType.IterableIteratorK:
    // any[]
    case ParameterType.AnyArray:
    // ArrayLike<T>
    case ParameterType.ArrayLikeT: {
      assertions.push(`types.isVectorNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.VectorNode');
      break;
    }

    // VECTOR NODE <STRING NODE | SYMBOL NODE>
    // ---------------------------------------

    // (string | symbol)[]
    case ParameterType.StringOrSymbolArray: {
      assertions.push(
        `types.isVectorNode(${ARGS_NAME}[${index}]) && (${ARGS_NAME}[${index}].value.every((x: types.AstNode) => types.isStringNode(x) || types.isSymbolNode(x)))`,
      );
      typeValues.push('types.VectorNode<types.StringNode | types.SymbolNode>');
      break;
    }

    // VECTOR NODE <NUMBER NODE>
    // -------------------------

    // any[]
    case ParameterType.OptionalAnyArray:
    // number[]
    case ParameterType.NumberArray:
    // Uint8Array
    case ParameterType.Uint16Array:
    // Uint32Array
    case ParameterType.Uint32Array:
    // Uint8Array
    case ParameterType.Uint8Array:
    // Uint8ClampedArray
    case ParameterType.Uint8ClampedArray:
    // BigInt64Array, BigUint64Array, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray, etc.
    case ParameterType.TypedNumberArray:
    // number[]
    case ParameterType.NumArr:
    // Iterable<number>
    case ParameterType.IterableNumber:
    // IterableIterator<number>
    case ParameterType.IterableIteratorNumber:
    // Int16Array
    case ParameterType.Int16Array:
    // Int32Array
    case ParameterType.Int32Array:
    // Int8Array
    case ParameterType.Int8Arr:
    // Int8Array
    case ParameterType.Int8Array:
    // Float32Array
    case ParameterType.Float32Array:
    // Float64Array
    case ParameterType.Float64Array:
    // type ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];
    case ParameterType.ArrayBufferLike:
    // ArrayBuffer
    case ParameterType.ArrayBuffer:
    // ArrayLike<number> | ArrayBuffer
    case ParameterType.ArrayLikeNumberOrArrayBuffer:
    // ArrayLike<number>
    case ParameterType.ArrayLikeNumeric:
    // BigInt64Array
    case ParameterType.BigInt64Array:
    // BigUint64Array
    case ParameterType.BigUint64Array: {
      assertions.push(
        // `types.isVectorNode(${ARGS_NAME}[${index}]) && types.isSequentialValues<types.NumberNode>(${ARGS_NAME}[${index}].value, types.NumberNode)`,
        `types.isVectorNode(${ARGS_NAME}[${index}]) && types.isTypedVector(${ARGS_NAME}[${index}], types.NumberNode)`,
      );
      typeValues.push('types.VectorNode<types.NumberNode>');
      break;
    }

    // VECTOR NODE <STRING NODE>
    // -------------------------

    // string[]
    case ParameterType.StringArray:
    // IterableIterator<string>
    case ParameterType.IterableIteratorString: {
      assertions.push(
        // `types.isVectorNode(${ARGS_NAME}[${index}]) && types.isSequentialValues<types.StringNode>(${ARGS_NAME}[${index}].value, types.StringNode)`,
        `types.isVectorNode(${ARGS_NAME}[${index}]) && types.isTypedVector(${ARGS_NAME}[${index}], types.StringNode)`,
      );
      typeValues.push('types.VectorNode<types.StringNode>');
      break;
    }

    // VECTOR NODE <SYMBOL NODE>
    // -------------------------

    // symbol[]
    case ParameterType.SymbolArray: {
      assertions.push(
        // `types.isVectorNode(${ARGS_NAME}[${index}]) && types.isSequentialValues<types.SymbolNode>(${ARGS_NAME}[${index}].value, types.SymbolNode)`,
        `types.isVectorNode(${ARGS_NAME}[${index}]) && types.isTypedVector(${ARGS_NAME}[${index}], types.SymbolNode)`,
      );
      typeValues.push('types.VectorNode<types.SymbolNode>');
      break;
    }

    // VECTOR NODE <VECTOR NODE <K, V>>  (K/V PAIRS)
    // --------------------------------------------
    // These MAP NODE versions are intendeded to be KV pairs

    // interface SegmentIterator { segment: string; index: number; isWordLike?: boolean; ... }
    case ParameterType.SegmentIterator:
    // interface ListFormatPart { type: string; value: string; }
    case ParameterType.ListFormatPartArray:
    // interface NumberFormatPart { type: string; value: string; }
    case ParameterType.NumberFormatPartArray:
    // interface RelativeTimeFormatPart { type: string; value: string; unit: string; }
    case ParameterType.RelativeTimeFormatPartArray:
    // interface DateTimeFormatPart { type: string; value: string | number; }
    case ParameterType.DateTimeFormatPartArray:
    // interface DateTimeRangeFormatPart { type: string; value: string | number; }
    case ParameterType.DateTimeRangeFormatPartArray:
    // Iterable<readonly [PropertyKey, T]>)>
    case ParameterType.IterableKV:
    // Partial<Record<K, T[]>>
    case ParameterType.PlainObjectWithTArrayValues:
    // IterableIterator<[number, number]>
    case ParameterType.IterableIteratorNumberNumber:
    // IterableIterator<[T, T]>
    case ParameterType.IterableIteratorTT:
    // IterableIterator<[number, T]>
    case ParameterType.IterableIteratorNumberT:
    // [string, T][]
    case ParameterType.KeyValueTArray:
    // IterableIterator<[K, V]>
    case ParameterType.IterableIteratorKV: {
      assertions.push(`(
        types.isVectorNode(${ARGS_NAME}[${index}]) &&
        (${ARGS_NAME}[${index}].value.length === 2) &&
        types.isAstNode(${ARGS_NAME}[${index}].value[0]) &&
        types.isAstNode(${ARGS_NAME}[${index}].value[1])
      )`);
      typeValues.push('types.VectorNode<types.VectorNode<types.AstNode>>');
      break;
    }

    // UNIONS
    // =================================================================================
    // Match the most specific type first, then the more general types and AST NODE last

    // AST NODE | NIL NODE
    // -------------------

    // object | null
    case ParameterType.ObjectOrNull:
    // T | undefined
    case ParameterType.TOrUndefined: {
      assertions.push(`(types.isNilNode(${ARGS_NAME}[${index}]) || types.isAstNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.AstNode');
      break;
    }

    // ATOM NODE | STRING NODE
    // -----------------------

    // type UnicodeBCP47LocaleIdentifier = string; type Locale = string | LocaleObject;
    case ParameterType.UnicodeBCP47LocaleIdentifierOrLocale: {
      assertions.push(`types.isStringNode(${ARGS_NAME}[${index}])`);
      typeValues.push('types.StringNode');
      break;
    }

    // FUNCTION NODE | NIL NODE
    // ------------------------

    // (v: number, k: number) => number | null
    case ParameterType.OptionalNumericFromMapFunction:
    // (() => void) | null
    case ParameterType.PromiseFinallyCallback:
    // (key: string, value: any) => any
    case ParameterType.Replacer:
    // ((v: T, k: number) => number) | null
    case ParameterType.OptFunTNumNum:
    // ((reason: any) => TResult | PromiseLike<TResult2>) | undefined | null
    case ParameterType.PromiseRejectedCallback: {
      assertions.push(`(types.isNilNode(${ARGS_NAME}[${index}]) || types.isFunctionNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.NilNode | types.FunctionNode');
      break;
    }

    // MAP NODE | NIL NODE
    // -------------------

    // Record<string, string | number | boolean>
    case ParameterType.OptRecStrNumBool:
    // () => void
    case ParameterType.RevocableProxy:
    // RegExpMatchArray | null */
    case ParameterType.RegExpMatchArrayOrNull:
    // PropertyDescriptor | undefined
    case ParameterType.PropertyDescriptorOrUndefined: {
      assertions.push(`(types.isNilNode(${ARGS_NAME}[${index}]) || types.isMapNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.NilNode | types.MapNode');
      break;
    }

    // MAP NODE | VECTOR NODE
    // ----------------------

    // { [s: string]: T } | ArrayLike<T>
    case ParameterType.PlainObjectTOrArrayLikeT:
    case ParameterType.PromiseMap: {
      assertions.push(`(types.isVectorNode(${ARGS_NAME}[${index}]) || types.isMapNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.VectorNode | types.MapNode');
      break;
    }

    // NIL NODE | NUMBER NODE
    // ----------------------

    // number | undefined
    case ParameterType.NumberOrUndefined: {
      assertions.push(`(types.isNilNode(${ARGS_NAME}[${index}]) || types.isNumberNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.NilNode | types.NumberNode');
      break;
    }

    // NUMBER NODE | STRING NODE
    // -------------------------

    // number | string
    case ParameterType.NumberOrString:
    // string | number
    case ParameterType.StringOrNumber: {
      assertions.push(`(types.isStringNode(${ARGS_NAME}[${index}]) || types.isNumberNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.StringNode | types.NumberNode');
      break;
    }

    // NIL NODE | STRING NODE
    // ----------------------

    // string | undefined
    case ParameterType.StringOrUndefined:
    // type LocalesArgument = | UnicodeBCP47LocaleIdentifier | Locale | readonly (UnicodeBCP47LocaleIdentifier | Locale)[] | undefined; */
    case ParameterType.LocalesArgument: {
      assertions.push(`(types.isNilNode(${ARGS_NAME}[${index}]) || types.isStringNode(${ARGS_NAME}[${index}]))`);
      typeValues.push('types.NilNode | types.StringNode');
      break;
    }

    // NIL NODE | VECTOR NODE
    // ----------------------

    // new <T extends WeakKey = WeakKey>(values?: readonly T[] | null): WeakSet<T>;
    case ParameterType.WeakKeyArrayOrNull:
    // new <K, V>(entries?: readonly (readonly [K, V])[] | null): Map<K, V>;
    case ParameterType.KeyValuePairsOrNull:
    // IterableIterator<[K, V]> | null
    case ParameterType.IterableIteratorKVOrNull: {
      assertions.push(
        `(types.isNilNode(${ARGS_NAME}[${index}]) || (types.isVectorNode(${ARGS_NAME}[${index}]) && (${ARGS_NAME}[${index}].value.length === 2) && types.isAstNode(${ARGS_NAME}[${index}].value[0]) && types.isAstNode(${ARGS_NAME}[${index}].value[1])) )`,
      );
      typeValues.push('types.NilNode | types.VectorNode<types.VectorNode<types.AstNode>>');
      break;
    }

    // NUMBER NODE | BOOLEAN NODE | STRING NODE
    // ----------------------------------------

    // bigint | boolean | number | string - Assuming NumberNode can handle bigint internally
    case ParameterType.BigIntOrBooleanOrNumberOrString: {
      assertions.push(
        `(types.isNumberNode(${ARGS_NAME}[${index}]) || types.isBooleanNode(${ARGS_NAME}[${index}]) || types.isStringNode(${ARGS_NAME}[${index}]))`,
      );
      typeValues.push('types.NumberNode | types.BooleanNode | types.StringNode');
      break;
    }

    // NUMBER NODE | STRING NODE| SYMBOL NODE
    // --------------------------------------

    // 'string | number | symbol
    case ParameterType.StringOrNumberOrSymbol: {
      assertions.push(
        `(types.isNumberNode(${ARGS_NAME}[${index}]) || types.isSymbolNode(${ARGS_NAME}[${index}]) || types.isStringNode(${ARGS_NAME}[${index}]))`,
      );
      typeValues.push('types.NumberNode | types.SymbolNode | types.StringNode');
      break;
    }

    // STRING NODE | VECTOR NODE <STRING NODE>
    // ---------------------------------------

    // string | string[]
    case ParameterType.StrOrStrArr:
    // string | string[]
    case ParameterType.StringOrStringArray: {
      // types.isSequentialValues<types.StringNode>(${ARGS_NAME}[${index}].value, types.StringNode)
      assertions.push(`((types.isStringNode(${ARGS_NAME}[${index}])) || 
        (types.isVectorNode(${ARGS_NAME}[${index}]) && types.isTypedVector(${ARGS_NAME}[${index}], types.StringNode)))`);
      typeValues.push('types.StringNode | types.VectorNode<types.StringNode>');
      break;
    }

    default: {
      assertions.push(`/* Parameter '${parameterName}' or type ${ParameterType[parameterType]} not handled */`);
    }
  }

  // assertions.push(`const a${index} = args[${index}].value${orUndefined}; // ${parameterName}`);
  return { assertions: assertions.join('\n'), typeValues: typeValues.join(' | ') };
}

if (import.meta.main) {
  const result = buildInterop(javascriptDefinitions as unknown as BuiltinCollection);
  console.log(result.join('\n'));
}
